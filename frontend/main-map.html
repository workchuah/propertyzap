<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Analysis - PropertyZap</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-light);
        }

        .map-wrapper {
            max-width: 1900px;
            margin: 1.5rem auto;
            padding: 0 1.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }

        .map-container {
            flex: 1;
            height: 760px;
            position: relative;
            border-radius: 14px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            border: 2px solid var(--border-color);
            transition: all 0.25s ease;
        }

        #map {
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* POI (Point of Interest) toggle panel on right side of map */
        .poi-toggle-panel {
            position: absolute;
            top: 70px;
            right: 14px;
            z-index: 1200;
            background: rgba(255, 255, 255, 0.96);
            border-radius: 12px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.18);
            padding: 0.75rem 0.9rem;
            min-width: 180px;
            font-size: 0.85rem;
            transition: transform 0.25s ease, opacity 0.25s ease;
        }

        .poi-toggle-title {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--text-dark);
            margin-bottom: 0.35rem;
        }

        .poi-toggle-subtitle {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-bottom: 0.4rem;
        }

        .poi-toggle-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .poi-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .poi-toggle-label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            color: var(--text-dark);
        }

        .poi-toggle-label span {
            font-size: 0.8rem;
        }

        .poi-switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 18px;
        }

        .poi-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .poi-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e5e7eb;
            transition: .3s;
            border-radius: 999px;
        }

        .poi-slider:before {
            position: absolute;
            content: "";
            height: 12px;
            width: 12px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        .poi-switch input:checked + .poi-slider {
            background-color: var(--primary-color);
        }

        .poi-switch input:checked + .poi-slider:before {
            transform: translateX(16px);
        }

        /* Trains group (KTM / MRT / LRT / Monorail) */
        .poi-train-group {
            border-top: 1px solid rgba(148, 163, 184, 0.3);
            padding-top: 0.35rem;
            margin-top: 0.15rem;
        }

        .poi-train-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.15rem;
        }

        .poi-train-main {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-dark);
            font-size: 0.85rem;
        }

        .poi-train-main span {
            font-size: 0.85rem;
        }

        .poi-train-caret {
            font-size: 0.7rem;
            color: var(--text-light);
        }

        .poi-train-children {
            margin-left: 1.2rem;
            display: none;
            flex-direction: column;
            gap: 0.2rem;
            margin-top: 0.2rem;
        }

        .poi-train-children.show {
            display: flex;
        }

        /* Schools group (Kindergarten / Primary / Highschool / College) */
        .poi-schools-group {
            border-top: 1px solid rgba(148, 163, 184, 0.3);
            padding-top: 0.35rem;
            margin-top: 0.15rem;
        }

        .poi-schools-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.15rem;
        }

        .poi-schools-main {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-dark);
            font-size: 0.85rem;
        }

        .poi-schools-main span {
            font-size: 0.85rem;
        }

        .poi-schools-caret {
            font-size: 0.7rem;
            color: var(--text-light);
        }

        .poi-schools-children {
            margin-left: 1.2rem;
            display: none;
            flex-direction: column;
            gap: 0.2rem;
            margin-top: 0.2rem;
        }

        .poi-schools-children.show {
            display: flex;
        }

        /* POI panel collapse toggle tab on right edge of map */
        .poi-panel-toggle-tab {
            position: absolute;
            top: 74px;
            right: 254px;
            width: 24px;
            height: 88px;
            border-top-left-radius: 999px;
            border-bottom-left-radius: 999px;
            background: #ffffff;
            border: 0px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1201;
            padding: 0;
            transition: right 0.25s ease, transform 0.25s ease;
        }

        .poi-panel-toggle-arrow {
            font-size: 14px;
            color: var(--text-dark);
        }

        /* Collapsed state: hide panel, keep small tab hugging map edge */
        body.poi-panel-collapsed .poi-toggle-panel {
            transform: translateX(130%);
            opacity: 0;
            pointer-events: none;
        }

        body.poi-panel-collapsed .poi-panel-toggle-tab {
            right: 2px;
        }

        /* Worship group (Mosque / Church / Temple / Other) */
        .poi-worship-group {
            border-top: 1px solid rgba(148, 163, 184, 0.3);
            padding-top: 0.35rem;
            margin-top: 0.15rem;
        }

        .poi-worship-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.15rem;
        }

        .poi-worship-main {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-dark);
            font-size: 0.85rem;
        }

        .poi-worship-main span {
            font-size: 0.85rem;
        }

        .poi-worship-caret {
            font-size: 0.7rem;
            color: var(--text-light);
        }

        .poi-worship-children {
            margin-left: 1.2rem;
            display: none;
            flex-direction: column;
            gap: 0.2rem;
            margin-top: 0.2rem;
        }

        .poi-worship-children.show {
            display: flex;
        }

        /* Generic POI icons on map */
        .poi-rail-icon-inner {
            width: 26px;
            height: 26px;
            border-radius: 999px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-size: 15px;
            box-shadow: 0 0 0 2px #ffffff, 0 4px 10px rgba(15, 23, 42, 0.35);
        }

        .poi-amenity-icon-inner {
            width: 24px;
            height: 24px;
            border-radius: 999px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-size: 15px;
            box-shadow: 0 0 0 2px #ffffff, 0 3px 8px rgba(15, 23, 42, 0.35);
        }

        .poi-rail-ktm .poi-rail-icon-inner {
            background: #0056a3; /* KTM blue */
        }

        .poi-rail-mrt .poi-rail-icon-inner {
            background: #00a651; /* MRT green */
        }

        .poi-rail-lrt .poi-rail-icon-inner {
            background: #e11d48; /* LRT red/magenta */
        }

        .poi-rail-monorail .poi-rail-icon-inner {
            background: #00acc1; /* Monorail teal */
        }

        .poi-hospital .poi-amenity-icon-inner {
            background: #e11d48; /* red/magenta similar to legend */
        }

        .poi-bus .poi-amenity-icon-inner {
            background: #fbbf24; /* amber/yellow */
            color: #1f2933;
        }

        .poi-school-kindergarten .poi-amenity-icon-inner {
            background: #f97316; /* orange */
        }

        .poi-school-primary .poi-amenity-icon-inner {
            background: #3b82f6; /* blue */
        }

        .poi-school-high .poi-amenity-icon-inner {
            background: #f1e863;
            color: #111827;
        }

        .poi-school-college .poi-amenity-icon-inner {
            background: #10b981; /* emerald */
        }

        .poi-worship-mosque .poi-amenity-icon-inner {
            background: #16a34a; /* green */
        }

        .poi-worship-church .poi-amenity-icon-inner {
            background: #2563eb; /* blue */
        }

        .poi-worship-temple .poi-amenity-icon-inner {
            background: #f97316; /* orange */
        }

        .poi-worship-other .poi-amenity-icon-inner {
            background: #6b21a8; /* purple */
        }

        /* Left pinned locations panel */
        .locations-panel {
            width: 300px;
            background: white;
            border-radius: 14px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.13);
            border: 1px solid var(--border-color);
            height: 760px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Scrollable content area */
        .locations-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            padding-bottom: 5rem; /* Space for fixed button */
        }

        /* Condos by Distance panel (between locations panel and map) */
        .condos-panel {
            width: 300px;
            background: white;
            border-radius: 14px;
            padding: 1.1rem;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.13);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            height: 760px;
            overflow: auto; /* Prevent panel itself from scrolling */
        }

        /* Ensure condo list scrolls within the panel */
        .condos-panel .locations-list {
            flex: 1;
            min-height: 0; /* Important for flex scrolling */
            overflow-y: auto;
            overflow-x: hidden;
        }

        .locations-panel-header {
            margin-bottom: 0.75rem;
        }

        .locations-panel-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-dark);
        }

        .locations-panel-subtitle {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .locations-budget {
            margin-bottom: 0.75rem;
        }

        .locations-budget-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.35rem;
        }

        .locations-budget-select {
            width: 100%;
            padding: 0.6rem 0.7rem;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            font-size: 0.75rem;
            background: #f9fafb;
            cursor: pointer;
        }

        .locations-budget-row {
            display: flex;
            gap: 0.5rem;
        }

        .locations-budget-row .locations-budget-select {
            width: 50%;
        }

        .locations-budget-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
        }


        .start-analysis-btn {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: calc(100% - 2.2rem);
            margin: 0 1.1rem 1.1rem 1.1rem;
            padding: 0.7rem 0.9rem;
            border-radius: 999px;
            border: none;
            background: var(--primary-color);
            color: white;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease;
        }

        .start-analysis-btn:hover {
            background: var(--primary-dark);
            box-shadow: 0 6px 18px rgba(37, 99, 235, 0.35);
            transform: translateY(-1px);
        }

        /* Tutorial mode toggle in header */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-light);
        }

        /* User Profile */
        .user-profile {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
        }

        .user-profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .user-profile-avatar:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .user-profile-avatar svg {
            width: 100%;
            height: 100%;
        }

        .user-profile-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .user-profile-name-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .user-profile-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .user-profile-menu {
            position: relative;
        }

        .user-profile-menu-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: var(--text-light);
            transition: color 0.2s ease;
        }

        .user-profile-menu-btn:hover {
            color: var(--primary-color);
        }

        .user-profile-menu-btn svg {
            width: 16px;
            height: 16px;
        }

        .user-profile-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1001;
        }

        .user-profile-menu.active .user-profile-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .user-profile-menu-item {
            display: block;
            padding: 0.75rem 1rem;
            color: var(--text-dark);
            text-decoration: none;
            font-size: 0.9rem;
            transition: background 0.2s ease;
            border-bottom: 1px solid var(--border-color);
        }

        .user-profile-menu-item:last-child {
            border-bottom: none;
        }

        .user-profile-menu-item:hover {
            background: var(--bg-light);
            color: var(--primary-color);
        }

        .user-profile-menu-item#userProfileLogout {
            color: #dc2626;
        }

        .user-profile-menu-item#userProfileLogout:hover {
            background: #fee2e2;
            color: #b91c1c;
        }

        .mode-switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 20px;
        }

        .mode-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #d1d5db;
            transition: .3s;
            border-radius: 999px;
        }

        .mode-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        .mode-switch input:checked + .mode-slider {
            background-color: var(--primary-color);
        }

        .mode-switch input:checked + .mode-slider:before {
            transform: translateX(16px);
        }

        .locations-list {
            flex: 1;
            border-radius: 10px;
            background: #f9fafb;
            padding: 0.5rem;
            overflow-y: visible;
        }

        .location-empty {
            font-size: 0.9rem;
            color: var(--text-light);
        }

        /* Condo distance groups */
        .condo-distance-group {
            margin-bottom: 1rem;
        }

        .condo-distance-label {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 0.4rem;
            padding: 0.3rem 0.5rem;
            background: rgba(37, 99, 235, 0.1);
            border-radius: 6px;
        }

        .condo-items {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .condo-item {
            background: white;
            border-radius: 10px;
            padding: 0.6rem 0.75rem;
            box-shadow: 0 3px 8px rgba(15, 23, 42, 0.06);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .condo-item:hover {
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12);
            transform: translateY(-1px);
        }

        .condo-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .condo-item-header-content {
            flex: 1;
        }

        .condo-monitor-toggle-wrapper {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .condo-monitor-toggle {
            position: relative;
            width: 36px;
            height: 20px;
            background: #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .condo-monitor-toggle.monitoring {
            background: var(--primary-color);
        }

        .condo-monitor-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .condo-monitor-toggle.monitoring .condo-monitor-toggle-slider {
            transform: translateX(16px);
        }

        .condo-item.expanded {
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
        }

        .condo-item-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0;
        }

        .condo-item.expanded .condo-item-details {
            max-height: 400px; /* Limit height so content can scroll */
            padding-top: 0.75rem;
            padding-bottom: 0.25rem;
            position: relative;
            overflow-y: auto; /* Allow scrolling inside the condo item */
        }
        
        .condo-view-details-btn {
            width: 100%;
            padding: 0.75rem;
            margin-top: 0.75rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .condo-view-details-btn:hover {
            background: var(--primary-dark);
        }
        
        /* Property Analysis Modal */
        .property-analysis-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .property-analysis-modal.show {
            display: flex;
        }
        
        .property-analysis-content {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 1200px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }
        
        .property-analysis-chart-section {
            flex: 0 0 50%;
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .property-analysis-table-section {
            flex: 0 0 50%;
            overflow-y: auto;
        }
        
        .property-analysis-chart {
            margin-top: 1.5rem;
        }
        
        .property-analysis-chart-grid {
            display: flex;
            gap: 2rem;
        }
        
        .property-analysis-chart-grid .chart-panel {
            flex: 1;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 1rem;
        }

        /* Box & whisker plots (inside property analysis charts) */
        .boxplot-section {
            margin-top: 1.25rem;
        }
        
        .boxplot-title {
            font-size: 0.9rem;
            color: var(--text-dark);
        }
        
        .boxplot-container {
            display: flex;
            margin-top: 0.75rem;
            align-items: center;
        }
        
        .boxplot-y-axis {
            width: 3rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-light);
        }
        
        .boxplot-plot {
            flex: 1;
            position: relative;
            height: 80px;
            margin-left: 0.5rem;
        }
        
        .boxplot-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(148, 163, 184, 0.9);
            transform: translateY(-50%);
        }
        
        .boxplot-whisker {
            position: absolute;
            top: 50%;
            width: 2px;
            height: 26px;
            background: rgba(148, 163, 184, 0.9);
            transform: translateY(-50%);
        }
        
        .boxplot-box {
            position: absolute;
            top: 50%;
            height: 26px;
            background: linear-gradient(to right, rgba(37, 99, 235, 0.18), rgba(37, 99, 235, 0.35));
            border: 2px solid #2563eb;
            border-radius: 4px;
            transform: translateY(-50%);
        }
        
        .boxplot-median {
            position: absolute;
            top: 50%;
            width: 2px;
            height: 30px;
            background: #1d4ed8;
            transform: translateY(-50%);
        }
        
        .boxplot-mean-dot {
            position: absolute;
            top: 50%;
            width: 8px;
            height: 8px;
            background: #111827;
            border-radius: 999px;
            transform: translate(-50%, -50%);
        }
        
        .boxplot-label {
            margin-top: 0.25rem;
            font-size: 0.75rem;
            color: var(--text-light);
            text-align: center;
        }
        
        .boxplot-x-axis {
            position: relative;
            margin-top: 0.35rem;
            height: 1.2rem;
            font-size: 0.75rem;
            color: var(--text-light);
            margin-left: 0.5rem;
            width: calc(100% - 0.5rem);
        }

        .boxplot-stat-label {
            position: absolute;
            bottom: 100%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: var(--text-light);
            white-space: nowrap;
        }
        
        /* Histogram styles (inside property analysis charts) */
        .histogram-section {
            margin-top: 1.25rem;
        }
        
        .histogram-title {
            font-size: 0.9rem;
            color: var(--text-dark);
        }
        
        .histogram-container {
            display: flex;
            margin-top: 0.75rem;
            height: 300px;
        }
        
        .histogram-y-axis {
            width: 3rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-light);
        }
        
        .histogram-bars {
            flex: 1;
            display: flex;
            align-items: flex-end;
            justify-content: space-evenly;
            gap: 0.4rem;
            padding: 0 0.75rem;
        }
        
        .histogram-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            height: 100%;
            justify-content: flex-end; /* keep bars anchored to bottom so they grow upwards */
        }
        
        .histogram-bin {
            width: 70%;
            margin: 0 auto;
            background: linear-gradient(to top, rgba(34, 197, 94, 0.9), rgba(22, 163, 74, 0.95));
            border-radius: 3px 3px 0 0;
            min-height: 5px;
        }
        
        .histogram-count-label {
            font-size: 0.65rem;
            color: var(--text-light);
            order: -1; /* render above the bar */
            margin-bottom: 0.15rem;
        }
        
        .histogram-x-axis {
            margin-top: 0.25rem;
            font-size: 0.75rem;
            color: var(--text-light);
            text-align: center;
        }

        /* Investment score (Appreciation Rate) */
        .investment-score-section {
            margin-top: 1.75rem;
            padding: 1rem 1.25rem;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.02);
            border: 1px solid var(--border-color);
        }
        
        .investment-score-main-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 0.5rem;
        }
        
        .investment-score-subtitle {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.75rem;
        }
        
        .investment-score-bar {
            display: flex;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.6);
            background: linear-gradient(to right, #fee2e2, #fef9c3, #dcfce7);
        }
        
        .investment-score-segment {
            flex: 1;
            text-align: center;
            padding: 0.4rem 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(15, 23, 42, 0.65);
            position: relative;
        }
        
        .investment-score-segment + .investment-score-segment {
            border-left: 1px solid rgba(148, 163, 184, 0.6);
        }
        
        .investment-score-segment.active {
            color: #fff;
        }
        
        .investment-score-segment.bad.active {
            background: linear-gradient(to right, #dc2626, #b91c1c);
        }
        
        .investment-score-segment.normal.active {
            background: linear-gradient(to right, #eab308, #ca8a04);
        }
        
        .investment-score-segment.good.active {
            background: linear-gradient(to right, #16a34a, #15803d);
        }
        
        .analysis-summary-section {
            margin-top: 1.75rem;
            padding: 1.25rem 1.5rem;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.02);
            border: 1px solid var(--border-color);
        }
        
        .analysis-summary-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 1rem;
        }
        
        .analysis-summary-content {
            font-size: 0.95rem;
            line-height: 1.6;
            color: var(--text-dark);
            padding: 1rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        
        .investment-score-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.75rem;
            font-size: 0.8rem;
            color: var(--text-light);
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .investment-score-meta strong {
            color: var(--text-dark);
        }
        
        .chart-bars {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 100%;
            padding: 0 1rem;
            gap: 0.5rem;
        }
        
        .chart-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            max-width: 80px;
            /* Ensure bar height scales relative to the full chart height */
            height: 100%;
        }
        
        .bar-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-end;
            position: relative;
        }
        
        .bar {
            width: 50%;
            background: linear-gradient(to top, var(--primary-color), var(--primary-dark));
            border-radius: 4px 4px 0 0;
            min-height: 20px;
            transition: opacity 0.2s;
            position: relative;
        }
        
        .bar:hover {
            opacity: 0.8;
        }
        
        .bar-median {
            background: linear-gradient(to top, #2563eb, #1d4ed8);
        }
        
        .bar-average {
            background: linear-gradient(to top, #22c55e, #16a34a);
        }
        
        .bar-value {
            position: absolute;
            top: -1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-dark);
            white-space: nowrap;
        }
        
        .bar-label {
            font-size: 0.85rem;
            color: var(--text-light);
            text-align: center;
            margin-top: 0.5rem;
            font-weight: 600;
        }
        
        .chart-y-axis {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem 0;
            font-size: 0.75rem;
            color: var(--text-light);
        }
        
        .chart-x-axis {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-dark);
        }
        
        .property-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .property-analysis-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-dark);
        }
        
        .property-analysis-header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .property-analysis-save {
            background: var(--primary-color);
            border: none;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .property-analysis-save:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }
        
        .property-analysis-save:active {
            transform: translateY(0);
        }
        
        .property-analysis-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
            padding: 0.25rem 0.5rem;
            transition: color 0.2s;
        }
        
        .property-analysis-close:hover {
            color: var(--primary-color);
        }
        
        .property-analysis-table-container {
            margin-top: 1.5rem;
            overflow-x: auto;
        }
        
        .property-analysis-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .property-analysis-table thead {
            background: var(--primary-color);
            color: white;
        }
        
        .property-analysis-table th {
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.85rem;
            white-space: nowrap;
        }
        
        .property-analysis-table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-dark);
        }
        
        .property-analysis-table tbody tr:hover {
            background: #f0f9ff;
        }
        
        .property-analysis-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .no-data-message {
            text-align: center;
            padding: 3rem;
            color: var(--text-light);
            font-size: 1rem;
        }

        .condo-property-info {
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .condo-property-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0;
            font-size: 0.8rem;
        }

        .condo-property-item:not(:last-child) {
            border-bottom: 1px solid #f3f4f6;
        }

        .condo-property-label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .condo-property-value {
            color: var(--text-light);
            font-size: 0.75rem;
            text-align: right;
        }

        .condo-route-info {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        .condo-route-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0;
            font-size: 0.8rem;
        }

        .condo-route-item:not(:last-child) {
            border-bottom: 1px solid #f3f4f6;
        }

        .condo-route-label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-weight: 600;
        }

        .condo-route-value {
            color: var(--text-light);
            font-size: 0.75rem;
        }

        .condo-loading-routes {
            text-align: center;
            padding: 0.5rem;
            color: var(--text-light);
            font-size: 0.75rem;
            font-style: italic;
        }

        .condo-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.2rem;
        }

        .condo-distance {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        /* Condo markers on map */
        .condo-marker {
            background: transparent !important;
            border: none !important;
        }
        
        /* Airbnb markers on map */
        .airbnb-marker {
            background: transparent !important;
            border: none !important;
            cursor: pointer;
            z-index: 500;
        }

        .location-item {
            background: white;
            border-radius: 10px;
            padding: 0.6rem 0.75rem;
            box-shadow: 0 3px 8px rgba(15, 23, 42, 0.06);
            border: 1px solid var(--border-color);
            margin-bottom: 0.35rem;
            position: relative;
        }

        .location-item:last-child {
            margin-bottom: 0;
        }

        .location-name {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.1rem;
        }

        .location-coords {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 0.5rem;
        }

        .location-opacity-control {
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .location-opacity-label {
            font-size: 0.75rem;
            color: var(--text-light);
            min-width: 50px;
        }

        .location-opacity-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .location-opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .location-opacity-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .location-opacity-value {
            font-size: 0.75rem;
            color: var(--text-dark);
            min-width: 35px;
            text-align: right;
            font-weight: 600;
        }

        .location-delete-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            border: none;
            background: #fee2e2;
            color: #b91c1c;
            border-radius: 50%;
            font-size: 1.1rem;
            font-weight: bold;
            width: 24px;
            height: 24px;
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            z-index: 10;
        }

        .location-delete-btn:hover {
            background: #fecaca;
        }

        /* Full Overlay for Step 1 */
        .step-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .step-overlay.hidden {
            display: none;
        }

        .step-overlay-content {
            background: white;
            border-radius: 18px;
            padding: 2.1rem;
            max-width: 480px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.05);
            animation: fadeInScale 0.3s ease;
            position: relative;
            z-index: 2001;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .step-indicator {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #e0e7ff;
            transition: all 0.3s;
        }

        .step-dot.active {
            background: var(--primary-color);
            width: 30px;
            border-radius: 5px;
        }

        .step-header h2 {
            font-size: 1.35rem;
            font-weight: 800;
            color: var(--text-dark);
            margin-bottom: 0.35rem;
        }

        .step-header p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-bottom: 0.8rem;
        }

        .question-options {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            margin-bottom: 1rem;
        }

        .option-btn {
            padding: 0.8rem 0.9rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: white;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .option-btn:hover {
            border-color: var(--primary-color);
            background: #f0f9ff;
        }

        .option-btn.selected {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            color: var(--primary-color);
        }

        .step-actions {
            display: flex;
            gap: 0.75rem;
        }

        .btn-next, .btn-submit {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-next {
            background: var(--primary-color);
            color: white;
        }

        .btn-next:hover {
            background: var(--primary-dark);
        }

        .btn-next:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }

        .btn-back {
            background: var(--bg-light);
            color: var(--text-dark);
            border: 2px solid var(--border-color);
        }

        .btn-back:hover {
            background: #e5e7eb;
            border-color: var(--text-light);
        }

        .btn-submit {
            background: var(--secondary-color);
            color: white;
        }

        .btn-submit:hover {
            background: #059669;
        }

        /* Map Search Control - Centered at top of map */
        .map-search-control {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1200;
            background: white;
            padding: 0.75rem 0.85rem;
            border-radius: 2px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 420px;
            max-width: 90%;
            transition: transform 0.25s ease, opacity 0.25s ease;
            will-change: auto;
        }

        .map-search-control.hidden {
            display: none;
        }

        /* Collapsed state: slide up and hide */
        .map-search-control.collapsed {
            transform: translateX(-50%) translateY(calc(-100% - 14px));
            opacity: 0;
            pointer-events: none;
        }

        /* Search bar toggle tab at bottom of search bar */
        .search-toggle-tab {
            position: absolute;
            top: calc(14px + 70px); /* Position below search bar (14px top + ~60px search bar height) */
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 24px;
            border-bottom-left-radius: 999px;
            border-bottom-right-radius: 999px;
            background: #ffffff;
            border: 0px solid var(--border-color);
            /* border-bottom: none; */
            /* box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); */
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1201;
            transition: all 0.25s ease;
        }

        /* Show toggle tab when search bar is visible */
        .map-search-control:not(.hidden) ~ .search-toggle-tab {
            display: flex;
        }

        .search-toggle-tab:hover {
            background: #f9fafb;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        }

        /* When search bar is collapsed, move toggle tab to top edge */
        body.search-collapsed .search-toggle-tab {
            top: 2px;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom-left-radius: 999px;
            border-bottom-right-radius: 999px;
        }

        .search-toggle-arrow {
            font-size: 14px;
            color: var(--text-dark);
        }

        body.search-collapsed .search-toggle-arrow {
            transform: rotate(180deg);
        }

        /* Highlight effect for search bar */
        .map-search-control.highlight {
            animation: pulseHighlight 2s infinite;
            border: 3px solid var(--primary-color);
        }

        @keyframes pulseHighlight {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
            }
            50% {
                box-shadow: 0 4px 20px rgba(37, 99, 235, 0.6), 0 0 0 4px rgba(37, 99, 235, 0.1);
            }
        }

        .search-input-group {
            position: relative;
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.4rem;
        }

        .search-input {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .search-input.highlight {
            border-color: var(--primary-color);
            animation: inputPulse 1.5s infinite;
        }

        @keyframes inputPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1);
            }
        }

        .search-btn {
            padding: 0.75rem 1.5rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .search-btn:hover {
            background: var(--primary-dark);
        }

        /* Dropdown Suggestions */
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 260px;
            overflow-y: auto;
            z-index: 1300;
            margin-top: 0.25rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
        }

        .search-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 0.6rem 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s;
        }

        .suggestion-item:hover {
            background: #f0f9ff;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .suggestion-address {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 0.1rem;
        }

        /* Step-by-step guide overlay */
        .guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }

        .guide-overlay.hidden {
            display: none;
        }

        .guide-box {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .guide-box h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 1rem;
        }

        .guide-box p {
            color: var(--text-light);
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .guide-box .guide-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .guide-btn {
            padding: 0.75rem 2rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .guide-btn:hover {
            background: var(--primary-dark);
        }

        /* New Tutorial Overlay System */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 5000;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .tutorial-overlay.active {
            opacity: 1;
        }

        .tutorial-overlay.hidden {
            display: none;
        }

        /* Spotlight effect using CSS mask */
        .tutorial-spotlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }

        /* Tutorial Tooltip/Chat Bubble */
        .tutorial-tooltip {
            position: absolute;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.25rem 1.5rem;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 5001;
            max-width: 320px;
            animation: tooltipBounce 0.6s ease;
            pointer-events: none;
        }

        @keyframes tooltipBounce {
            0% {
                opacity: 0;
                transform: translateY(-10px) scale(0.9);
            }
            50% {
                transform: translateY(5px) scale(1.02);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .tutorial-tooltip::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }

        .tutorial-tooltip.arrow-down::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 12px 12px 0 12px;
            border-color: #667eea transparent transparent transparent;
        }

        .tutorial-tooltip.arrow-up::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 12px 12px 12px;
            border-color: transparent transparent #667eea transparent;
        }

        .tutorial-tooltip-text {
            font-size: 1rem;
            font-weight: 600;
            line-height: 1.5;
            text-align: center;
        }

        /* Lock UI when tutorial is active */
        body.tutorial-locked {
            overflow: hidden;
            /* Prevent layout shift by maintaining scrollbar width */
            padding-right: 0;
        }
        
        /* Ensure map container doesn't shift */
        body.tutorial-locked .map-container {
            position: relative;
        }

        body.tutorial-locked .map-container,
        body.tutorial-locked .locations-panel,
        body.tutorial-locked .leaflet-control-container,
        body.tutorial-locked .start-analysis-btn {
            pointer-events: none;
            user-select: none;
        }

        /* Keep header and user profile always clickable even during tutorial */
        body.tutorial-locked header,
        body.tutorial-locked .user-profile,
        body.tutorial-locked .user-profile-menu,
        body.tutorial-locked .user-profile-menu-btn,
        body.tutorial-locked .user-profile-avatar,
        body.tutorial-locked .user-profile-name,
        body.tutorial-locked .user-profile-dropdown,
        body.tutorial-locked .mode-toggle {
            pointer-events: auto !important;
            user-select: auto !important;
        }

        /* Keep Step 1 overlay content clickable during tutorial */
        body.tutorial-locked .step-overlay {
            pointer-events: all !important;
            z-index: 5001 !important; /* Above tutorial overlay (5000) */
        }

        body.tutorial-locked .step-overlay-content {
            pointer-events: all;
            position: relative;
            z-index: 5002;
        }

        body.tutorial-locked .question-options {
            pointer-events: all;
            position: relative;
            z-index: 5003;
        }

        body.tutorial-locked .option-btn {
            pointer-events: all;
            cursor: pointer;
            position: relative;
            z-index: 5004;
        }

        body.tutorial-locked .btn-next {
            pointer-events: all;
            cursor: pointer;
            position: relative;
            z-index: 5004;
        }

        /* Keep location popup clickable during tutorial */
        body.tutorial-locked .location-popup {
            pointer-events: all !important;
            z-index: 5005 !important;
        }

        body.tutorial-locked .location-popup .popup-btn {
            pointer-events: all;
            cursor: pointer;
            position: relative;
            z-index: 5006;
        }

        /* Keep budget section clickable during tutorial - ONLY after work location is set */
        body.tutorial-locked.work-location-set .locations-budget {
            pointer-events: all !important;
            z-index: 5005 !important;
        }

        body.tutorial-locked.work-location-set .locations-budget .locations-budget-select {
            pointer-events: all;
            cursor: pointer;
            position: relative;
            z-index: 5006;
        }

        /* Keep Start Analysis button clickable during tutorial - ONLY after budget is set */
        body.tutorial-locked.budget-set .start-analysis-btn {
            pointer-events: all !important;
            cursor: pointer;
            position: relative;
            z-index: 5007 !important;
        }

        body.tutorial-locked .map-search-control {
            pointer-events: all;
            z-index: 5002;
            position: absolute !important;
            top: 14px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
        }

        body.tutorial-locked .map-search-control .search-input,
        body.tutorial-locked .map-search-control .search-btn {
            pointer-events: all;
            cursor: pointer;
        }

        /* Location confirmation popup */
        .location-popup {
            position: absolute;
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            min-width: 280px;
            animation: popupSlide 0.3s ease;
        }

        @keyframes popupSlide {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .location-popup.hidden {
            display: none;
        }

        .location-popup h4 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 0.75rem;
        }

        .location-popup p {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1rem;
        }

        .location-type-select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
            color: var(--text-dark);
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .location-type-select:hover {
            border-color: var(--primary-color);
        }

        .location-type-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .location-popup-actions {
            display: flex;
            gap: 0.5rem;
        }

        .popup-btn {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .popup-btn-confirm {
            background: var(--primary-color);
            color: white;
        }

        .popup-btn-confirm:hover {
            background: var(--primary-dark);
        }

        .popup-btn-cancel {
            background: var(--bg-light);
            color: var(--text-dark);
        }

        .popup-btn-cancel:hover {
            background: #e5e7eb;
        }

        /* Budget select */
        .budget-select {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            margin-bottom: 1.5rem;
        }

        .budget-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .coming-soon-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .coming-soon-box h3 {
            color: #78350f;
            margin-bottom: 0.5rem;
        }

        .coming-soon-box p {
            color: #92400e;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .map-wrapper {
                padding: 0 1rem;
                flex-direction: column;
            }

            .locations-panel {
                width: 100%;
            }

            .map-container {
                height: 520px;
            }

            .map-search-control {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
            }
        }

        /* Ensure header is always on top of all overlays */
        .header {
            z-index: 6000 !important;
            position: relative;
        }

        /* Ensure user profile is clickable and above header */
        .user-profile {
            position: relative;
            z-index: 6001;
        }

        /* Ensure user profile dropdown is above everything */
        .user-profile-dropdown {
            z-index: 6002 !important;
        }

        /* Ensure user profile menu button is always clickable */
        .user-profile-menu-btn,
        .user-profile-avatar,
        .user-profile-name {
            position: relative;
            z-index: 6001;
            pointer-events: auto !important;
        }

        /* Notification Bell */
        .notification-bell {
            position: relative;
        }

        .notification-bell-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dark);
            position: relative;
            transition: color 0.2s;
        }

        .notification-bell-btn:hover {
            color: var(--primary-color);
        }

        .notification-badge {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 700;
            border: 2px solid white;
        }

        .notification-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border-color);
            min-width: 320px;
            max-width: 400px;
            max-height: 500px;
            z-index: 6003;
            overflow: hidden;
        }

        .notification-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .notification-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-dark);
        }

        .notification-clear-btn {
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 0.85rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .notification-clear-btn:hover {
            background: #f3f4f6;
        }

        .notification-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .notification-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
        }

        .notification-item:hover {
            background: #f9fafb;
        }

        .notification-item.unread {
            background: #eff6ff;
        }

        .notification-item-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 0.25rem;
        }

        .notification-item-message {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-bottom: 0.25rem;
        }

        .notification-item-time {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .notification-empty {
            padding: 2rem 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">PropertyZap</div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <!-- Primary actions -->
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-right: 0.5rem;">
                        <a href="buy-sell-map.html" class="primary-btn" style="padding: 0.45rem 0.95rem; font-size: 0.85rem;">Buy/Sell Property</a>
                    </div>

                    <!-- Tutorial toggle -->
                    <div class="mode-toggle">
                        <span class="mode-label">Tutorial</span>
                        <label class="mode-switch">
                            <input type="checkbox" id="tutorialToggle">
                            <span class="mode-slider"></span>
                        </label>
                    </div>

                    <!-- Notifications -->
                    <div class="notification-bell" id="notificationBell">
                        <button class="notification-bell-btn" id="notificationBellBtn" onclick="toggleNotificationDropdown()">
                            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M10 2C7.23858 2 5 4.23858 5 7V10.5858L3.29289 12.2929C3.10536 12.4804 3 12.7348 3 13V14C3 14.5523 3.44772 15 4 15H16C16.5523 15 17 14.5523 17 14V13C17 12.7348 16.8946 12.4804 16.7071 12.2929L15 10.5858V7C15 4.23858 12.7614 2 10 2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8 15V16C8 17.1046 8.89543 18 10 18C11.1046 18 12 17.1046 12 16V15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
                        </button>
                        <div class="notification-dropdown" id="notificationDropdown" style="display: none;">
                            <div class="notification-header">
                                <div class="notification-title">Notifications</div>
                                <button class="notification-clear-btn" onclick="clearAllNotifications()">Clear All</button>
                            </div>
                            <div class="notification-list" id="notificationList">
                                <div class="notification-empty">No notifications</div>
                            </div>
                        </div>
                    </div>

                    <!-- User profile -->
                    <div class="user-profile">
                        <div class="user-profile-avatar" id="userProfileAvatar">
                            <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="16" cy="16" r="16" fill="#e5e7eb"/>
                                <path d="M16 10C17.6569 10 19 11.3431 19 13C19 14.6569 17.6569 16 16 16C14.3431 16 13 14.6569 13 13C13 11.3431 14.3431 10 16 10Z" fill="#6b7280"/>
                                <path d="M16 18C18.7614 18 21 20.2386 21 23V24H11V23C11 20.2386 13.2386 18 16 18Z" fill="#6b7280"/>
                            </svg>
                        </div>
                        <div class="user-profile-info">
                            <div class="user-profile-menu" id="userProfileMenu">
                                <div class="user-profile-name-row">
                                    <span class="user-profile-name" id="userProfileName">User</span>
                                    <button class="user-profile-menu-btn" id="userProfileMenuBtn">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    </button>
                                </div>
                                <div class="user-profile-dropdown" id="userProfileDropdown">
                                    <a href="user-profile.html" class="user-profile-menu-item" id="userProfileCompleteProfile">User Profile</a>
                                    <a href="#" class="user-profile-menu-item" id="userProfileLogout">Logout</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <div class="map-wrapper">
        <!-- Left pinned locations & budget panel -->
        <aside class="locations-panel">
            <div class="locations-panel-content">
                <div class="locations-panel-header">
                    <div class="locations-panel-title">Your Budget & Locations</div>
                    <div class="locations-panel-subtitle">Set your budget in MYR and see pinned spots.</div>
                </div>

                <div class="locations-budget">
                <div class="locations-budget-label">Budget Range (MYR)</div>
                <div class="locations-budget-row">
                    <select id="sidebarBudgetMin" class="locations-budget-select">
                        <option value="">Min</option>
                        <option value="0">RM 0</option>
                        <option value="100000">RM 100,000</option>
                        <option value="200000">RM 200,000</option>
                        <option value="300000">RM 300,000</option>
                        <option value="400000">RM 400,000</option>
                        <option value="500000">RM 500,000</option>
                        <option value="600000">RM 600,000</option>
                        <option value="700000">RM 700,000</option>
                        <option value="800000">RM 800,000</option>
                        <option value="900000">RM 900,000</option>
                        <option value="1000000">RM 1,000,000</option>
                        <option value="1100000">RM 1,100,000</option>
                        <option value="1200000">RM 1,200,000</option>
                        <option value="1300000">RM 1,300,000</option>
                        <option value="1400000">RM 1,400,000</option>
                        <option value="1500000">RM 1,500,000</option>
                        <option value="1600000">RM 1,600,000</option>
                        <option value="1700000">RM 1,700,000</option>
                        <option value="1800000">RM 1,800,000</option>
                        <option value="1900000">RM 1,900,000</option>
                        <option value="2000000">RM 2,000,000</option>
                        <option value="2100000">RM 2,100,000</option>
                        <option value="2200000">RM 2,200,000</option>
                        <option value="2300000">RM 2,300,000</option>
                        <option value="2400000">RM 2,400,000</option>
                        <option value="2500000">RM 2,500,000</option>
                        <option value="2600000">RM 2,600,000</option>
                        <option value="2700000">RM 2,700,000</option>
                        <option value="2800000">RM 2,800,000</option>
                        <option value="2900000">RM 2,900,000</option>
                        <option value="3000000">RM 3,000,000</option>
                        <option value="3100000">RM 3,500,000</option>
                        <option value="3200000">RM 4,000,000</option>
                        <option value="3300000">RM 4,500,000</option>
                        <option value="3400000">RM 5,000,000</option>
                        <option value="3500000">RM 5,500,000</option>
                        <option value="3600000">RM 6,000,000</option>
                        <option value="3700000">RM 6,500,000</option>
                        <option value="3800000">RM 7,000,000</option>
                        <option value="3900000">RM 7,500,000</option>
                        <option value="4000000">RM 8,000,000</option>
                        <option value="4100000">RM 8,500,000</option>
                        <option value="4200000">RM 9,000,000</option>
                        <option value="4300000">RM 9,500,000</option>
                        <option value="4400000">RM 10,000,000</option>
                    </select>
                    <select id="sidebarBudgetMax" class="locations-budget-select">
                        <option value="">Max</option>
                        <option value="100000">RM 100,000</option>
                        <option value="200000">RM 200,000</option>
                        <option value="300000">RM 300,000</option>
                        <option value="400000">RM 400,000</option>
                        <option value="500000">RM 500,000</option>
                        <option value="600000">RM 600,000</option>
                        <option value="700000">RM 700,000</option>
                        <option value="800000">RM 800,000</option>
                        <option value="900000">RM 900,000</option>
                        <option value="1000000">RM 1,000,000</option>
                        <option value="1100000">RM 1,100,000</option>
                        <option value="1200000">RM 1,200,000</option>
                        <option value="1300000">RM 1,300,000</option>
                        <option value="1400000">RM 1,400,000</option>
                        <option value="1500000">RM 1,500,000</option>
                        <option value="1600000">RM 1,600,000</option>
                        <option value="1700000">RM 1,700,000</option>
                        <option value="1800000">RM 1,800,000</option>
                        <option value="1900000">RM 1,900,000</option>
                        <option value="2000000">RM 2,000,000</option>
                        <option value="2100000">RM 2,100,000</option>
                        <option value="2200000">RM 2,200,000</option>
                        <option value="2300000">RM 2,300,000</option>
                        <option value="2400000">RM 2,400,000</option>
                        <option value="2500000">RM 2,500,000</option>
                        <option value="2600000">RM 2,600,000</option>
                        <option value="2700000">RM 2,700,000</option>
                        <option value="2800000">RM 2,800,000</option>
                        <option value="2900000">RM 2,900,000</option>
                        <option value="3000000">RM 3,000,000</option>
                        <option value="3100000">RM 3,500,000</option>
                        <option value="3200000">RM 4,000,000</option>
                        <option value="3300000">RM 4,500,000</option>
                        <option value="3400000">RM 5,000,000</option>
                        <option value="3500000">RM 5,500,000</option>
                        <option value="3600000">RM 6,000,000</option>
                        <option value="3700000">RM 6,500,000</option>
                        <option value="3800000">RM 7,000,000</option>
                        <option value="3900000">RM 7,500,000</option>
                        <option value="4000000">RM 8,000,000</option>
                        <option value="4100000">RM 8,500,000</option>
                        <option value="4200000">RM 9,000,000</option>
                        <option value="4300000">RM 9,500,000</option>
                        <option value="4400000">RM 10,000,000</option>
                    </select>
                </div>
            </div>

                <!-- Property Size Range (shown for own-stay) -->
                <div class="locations-budget" id="propertySizeFilter" style="display: none;">
                <div class="locations-budget-label">Property Size Range (sqft)</div>
                <div class="locations-budget-row">
                    <select id="sidebarPropertySizeMin" class="locations-budget-select">
                        <option value="">Min</option>
                        <option value="300">300 sqft</option>
                        <option value="400">400 sqft</option>
                        <option value="500">500 sqft</option>
                        <option value="600">600 sqft</option>
                        <option value="700">700 sqft</option>
                        <option value="800">800 sqft</option>
                        <option value="900">900 sqft</option>
                        <option value="1000">1,000 sqft</option>
                        <option value="1200">1,200 sqft</option>
                        <option value="1500">1,500 sqft</option>
                        <option value="2000">2,000 sqft</option>
                    </select>
                    <select id="sidebarPropertySizeMax" class="locations-budget-select">
                        <option value="">Max</option>
                        <option value="800">800 sqft</option>
                        <option value="900">900 sqft</option>
                        <option value="1000">1,000 sqft</option>
                        <option value="1200">1,200 sqft</option>
                        <option value="1500">1,500 sqft</option>
                        <option value="2000">2,000 sqft</option>
                        <option value="2500">2,500 sqft</option>
                        <option value="3000">3,000 sqft</option>
                        <option value="4000">4,000 sqft</option>
                        <option value="5000">5,000 sqft</option>
                        <option value="10000">10,000+ sqft</option>
                    </select>
                </div>
                </div>

                <!-- Investment-specific filters (shown only for investment) -->
                <div class="locations-budget" id="investmentTypeFilter" style="display: none;">
                    <div class="locations-budget-label">Preferred Investment Type</div>
                    <div class="locations-budget-row">
                        <select id="sidebarInvestmentType" class="locations-budget-select">
                            <option value="">Select Type</option>
                            <option value="long-stay">Long-stay</option>
                            <option value="short-stay">Short-stay</option>
                        </select>
                    </div>
                </div>

                <div class="locations-budget" id="minimumROIFilter" style="display: none;">
                    <div class="locations-budget-label">Minimum ROI (%)</div>
                    <div class="locations-budget-row">
                        <input type="number" id="sidebarMinimumROI" class="locations-budget-select" placeholder="e.g., 5.5" min="0" max="100" step="0.1" style="width: 100%;">
                    </div>
                </div>

                <!-- Advanced Filter Toggle -->
                <div class="locations-budget" style="margin-top: 1rem; margin-bottom: 1rem;">
                    <button id="advancedFilterToggle" class="advanced-filter-btn" style="width: 100%; padding: 0.75rem; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 0.9rem; color: #374151; display: flex; align-items: center; justify-content: space-between; transition: all 0.2s;">
                        <span>Advanced Filter</span>
                        <span id="advancedFilterIcon" style="font-size: 0.8rem; transition: transform 0.2s;"></span>
                    </button>
                </div>

                <!-- Advanced Filter Sections (shown when advanced filter is expanded) -->
                <!-- For Own Stay: Show Investment Type and Minimum ROI -->
                <div class="locations-budget" id="advancedInvestmentTypeFilter" style="display: none;">
                    <div class="locations-budget-label">Preferred Investment Type</div>
                    <div class="locations-budget-row">
                        <select id="advancedInvestmentType" class="locations-budget-select">
                            <option value="">Select Type</option>
                            <option value="long-stay">Long-stay</option>
                            <option value="short-stay">Short-stay</option>
                        </select>
                    </div>
                </div>

                <div class="locations-budget" id="advancedMinimumROIFilter" style="display: none;">
                    <div class="locations-budget-label">Minimum ROI (%)</div>
                    <div class="locations-budget-row">
                        <input type="number" id="advancedMinimumROI" class="locations-budget-select" placeholder="e.g., 5.5" min="0" max="100" step="0.1" style="width: 100%;">
                    </div>
                </div>

                <!-- For Investment: Show Property Size Range in advanced mode (positioned after Advanced Filter button) -->
                <div class="locations-budget" id="advancedPropertySizeFilter" style="display: none;">
                    <div class="locations-budget-label">Property Size Range (sqft)</div>
                    <div class="locations-budget-row">
                        <select id="advancedPropertySizeMin" class="locations-budget-select">
                            <option value="">Min</option>
                            <option value="300">300 sqft</option>
                            <option value="400">400 sqft</option>
                            <option value="500">500 sqft</option>
                            <option value="600">600 sqft</option>
                            <option value="700">700 sqft</option>
                            <option value="800">800 sqft</option>
                            <option value="900">900 sqft</option>
                            <option value="1000">1,000 sqft</option>
                            <option value="1200">1,200 sqft</option>
                            <option value="1500">1,500 sqft</option>
                            <option value="2000">2,000 sqft</option>
                        </select>
                        <select id="advancedPropertySizeMax" class="locations-budget-select">
                            <option value="">Max</option>
                            <option value="800">800 sqft</option>
                            <option value="900">900 sqft</option>
                            <option value="1000">1,000 sqft</option>
                            <option value="1200">1,200 sqft</option>
                            <option value="1500">1,500 sqft</option>
                            <option value="2000">2,000 sqft</option>
                            <option value="2500">2,500 sqft</option>
                            <option value="3000">3,000 sqft</option>
                            <option value="4000">4,000 sqft</option>
                            <option value="5000">5,000 sqft</option>
                            <option value="10000">10,000+ sqft</option>
                        </select>
                    </div>
                </div>

                <div class="locations-panel-header">
                    <div class="locations-panel-title">Pinned Locations</div>
                    <div class="locations-panel-subtitle">Each location you set on the map will appear here.</div>
                </div>

                <div class="locations-list" id="pinnedLocationsList">
                    <p class="location-empty">No locations pinned yet. Search or click on the map to start.</p>
                </div>
            </div>

            <button class="start-analysis-btn" type="button" onclick="startSidebarAnalysis()">Start Analysis</button>
        </aside>

        <div class="map-container">
            <div id="map"></div>
            
            <!-- Map Search Control -->
            <div class="map-search-control hidden" id="mapSearchControl">
                <div class="search-input-group">
                    <input type="text" class="search-input" id="locationSearch" placeholder="Search for location...">
                    <button class="search-btn" onclick="searchLocation()">Search</button>
                    <div class="search-suggestions" id="searchSuggestions"></div>
                </div>
            </div>

            <!-- Search bar collapse / expand tab (at bottom of search bar) -->
            <button class="search-toggle-tab" id="searchToggleTab" type="button" onclick="toggleSearchBar()">
                <span class="search-toggle-arrow" id="searchToggleArrow"></span>
            </button>

            <!-- POI Toggle Panel (right side of map) -->
            <div class="poi-toggle-panel">
                <div class="poi-toggle-title">Nearby Places</div>
                <div class="poi-toggle-subtitle">Toggle important amenities on the map.</div>
                <div class="poi-toggle-group">
                    <label class="poi-toggle">
                        <div class="poi-toggle-label">
                            <span></span>
                            <span>Hospitals</span>
                        </div>
                        <label class="poi-switch">
                            <input type="checkbox" id="toggleHospitals" onchange="toggleHospitals(this.checked)">
                            <span class="poi-slider"></span>
                        </label>
                    </label>

                    <div class="poi-schools-group">
                        <div class="poi-schools-header">
                            <button type="button" class="poi-schools-main" onclick="toggleSchoolsDropdown()">
                                <span></span>
                                <span>Schools / University</span>
                                <span class="poi-schools-caret" id="schoolsCaret"></span>
                            </button>
                            <label class="poi-switch">
                                <input type="checkbox" id="toggleSchools" onchange="toggleSchools(this.checked)">
                                <span class="poi-slider"></span>
                            </label>
                        </div>
                        <div class="poi-schools-children" id="schoolsChildren">
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Kindergarten</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleKindergarten" onchange="toggleKindergarten(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Primary School</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="togglePrimary" onchange="togglePrimary(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Highschool</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleHighschool" onchange="toggleHighschool(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>College / University</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleCollege" onchange="toggleCollege(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                        </div>
                    </div>

                    <div class="poi-worship-group">
                        <div class="poi-worship-header">
                            <button type="button" class="poi-worship-main" onclick="toggleWorshipDropdown()">
                                <span></span>
                                <span>Worship</span>
                                <span class="poi-worship-caret" id="worshipCaret"></span>
                            </button>
                            <label class="poi-switch">
                                <input type="checkbox" id="toggleWorship" onchange="toggleWorship(this.checked)">
                                <span class="poi-slider"></span>
                            </label>
                        </div>
                        <div class="poi-worship-children" id="worshipChildren">
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Mosque</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleMosque" onchange="toggleMosque(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Church</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleChurch" onchange="toggleChurch(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Temple</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleTemple" onchange="toggleTemple(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Other</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleOtherWorship" onchange="toggleOtherWorship(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                        </div>
                    </div>

                    <div class="poi-train-group">
                        <div class="poi-train-header">
                            <button type="button" class="poi-train-main" onclick="toggleTrainsDropdown()">
                                <span></span>
                                <span>Trains</span>
                                <span class="poi-train-caret" id="trainCaret"></span>
                            </button>
                            <label class="poi-switch">
                                <input type="checkbox" id="toggleTrains" onchange="toggleTrains(this.checked)">
                                <span class="poi-slider"></span>
                            </label>
                        </div>
                        <div class="poi-train-children" id="trainChildren">
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>KTM</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleKTM" onchange="toggleKTM(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>MRT</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleMRT" onchange="toggleMRT(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>LRT</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleLRT" onchange="toggleLRT(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                            <label class="poi-toggle">
                                <div class="poi-toggle-label">
                                    <span></span>
                                    <span>Monorail</span>
                                </div>
                                <label class="poi-switch">
                                    <input type="checkbox" id="toggleMonorail" onchange="toggleMonorail(this.checked)">
                                    <span class="poi-slider"></span>
                                </label>
                            </label>
                        </div>
                    </div>

                    <label class="poi-toggle">
                        <div class="poi-toggle-label">
                            <span></span>
                            <span>Bus Stops & Stations</span>
                        </div>
                        <label class="poi-switch">
                            <input type="checkbox" id="toggleBus" onchange="toggleBus(this.checked)">
                            <span class="poi-slider"></span>
                        </label>
                    </label>
                </div>
            </div>

            <!-- POI panel collapse / expand tab -->
            <button class="poi-panel-toggle-tab" id="poiPanelToggleTab" type="button" onclick="togglePoiPanel()">
                <span class="poi-panel-toggle-arrow" id="poiPanelToggleArrow"></span>
            </button>

            <!-- Step 1: Full Overlay - Purpose Selection -->
            <div class="step-overlay" id="step1Overlay">
                <div class="step-overlay-content">
                    <div class="step-indicator">
                        <div class="step-dot active"></div>
                        <div class="step-dot"></div>
                        <div class="step-dot"></div>
                    </div>
                    <div class="step-header">
                        <h2>Let's Get Started!</h2>
                        <p>Help us understand your property needs</p>
                    </div>
                    <div class="question-options">
                        <button type="button" class="option-btn" data-value="own-stay" onclick="selectOption(this, 'purpose')">
                             Own Stay
                        </button>
                        <button type="button" class="option-btn" data-value="investment" onclick="selectOption(this, 'purpose')">
                             Investment
                        </button>
                    </div>
                    <div class="step-actions">
                        <button class="btn-next" id="nextBtn1" onclick="nextStep(2)" disabled>Next</button>
                    </div>
                </div>
            </div>

            <!-- Guide Overlay for Step-by-step instructions -->
            <div class="guide-overlay hidden" id="guideOverlay">
                <div class="guide-box">
                    <div class="guide-icon" id="guideIcon"></div>
                    <h3 id="guideTitle">Step 1: Search for Location</h3>
                    <p id="guideText">Type your work address in the search box at the top-left of the map</p>
                    <button class="guide-btn" onclick="closeGuide()">Got it!</button>
                </div>
            </div>

            <!-- New Tutorial Overlay System -->
            <div class="tutorial-overlay hidden" id="tutorialOverlay">
                <div class="tutorial-spotlight" id="tutorialSpotlight"></div>
                <div class="tutorial-tooltip arrow-down" id="tutorialTooltip">
                    <div class="tutorial-tooltip-text">Type your work location here and click search.</div>
                </div>
            </div>

            <!-- Location Confirmation Popup -->
            <div class="location-popup hidden" id="locationPopup">
                <h4>Selected Location</h4>
                <p id="popupLocationName">Location name will appear here</p>
                <p id="popupLocationCoords" style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 0.5rem;"></p>
                <div style="margin-bottom: 1rem;">
                    <label for="locationTypeSelect" style="display: block; font-size: 0.85rem; color: var(--text-dark); margin-bottom: 0.5rem; font-weight: 600;">Location Type:</label>
                    <select id="locationTypeSelect" class="location-type-select" onchange="updateLocationButtonText()">
                        <option value="Work">Work</option>
                        <option value="School">School</option>
                        <option value="Home">Home</option>
                        <option value="Preferred">Preferred</option>
                        <option value="Others">Others</option>
                    </select>
                    <input type="text" id="locationTypeCustom" class="location-type-custom" placeholder="e.g., Preferred Location" style="display: none; margin-top: 0.5rem; width: 100%; padding: 0.6rem; border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9rem; background: white; color: var(--text-dark);" oninput="updateLocationButtonText()">
                </div>
                <div class="location-popup-actions">
                    <button class="popup-btn popup-btn-confirm" id="confirmLocationBtn" onclick="confirmLocation()">Pin Location</button>
                    <button class="popup-btn popup-btn-cancel" onclick="cancelLocation()">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Condos by Distance Panel (right side of map) -->
        <aside class="condos-panel" id="condosPanel" style="display: none;">
            <div class="locations-panel-header">
                <div class="locations-panel-title">Condos by Distance</div>
                <div class="locations-panel-subtitle">Properties found within analysis radius.</div>
                <!-- CSV file input for loading condos from CSV file -->
                <!-- <div style="margin-top: 0.5rem;">
                    <label for="csvFileInput" style="display: inline-block; padding: 0.4rem 0.75rem; background: var(--primary-color); color: white; border-radius: 6px; font-size: 0.75rem; cursor: pointer; transition: background 0.2s;">
                         Load CSV
                    </label>
                    <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="if(this.files[0]) loadCSVFile(this.files[0])">
                </div> -->
            </div>

            <div class="locations-list" id="condosList">
                <div class="condo-distance-group" id="condoGroup0to3">
                    <div class="condo-distance-label">Within 3km</div>
                    <div class="condo-items" id="condos0to3"></div>
                </div>
                <div class="condo-distance-group" id="condoGroup3to6">
                    <div class="condo-distance-label">3km - 6km</div>
                    <div class="condo-items" id="condos3to6"></div>
                </div>
                <div class="condo-distance-group" id="condoGroup6to9">
                    <div class="condo-distance-label">6km - 9km</div>
                    <div class="condo-items" id="condos6to9"></div>
                </div>
                <div class="condo-distance-group" id="condoGroup9to12">
                    <div class="condo-distance-label">9km - 12km</div>
                    <div class="condo-items" id="condos9to12"></div>
                </div>
            </div>
        </aside>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize Map (Malaysia centered)
        const map = L.map('map').setView([3.1390, 101.6869], 11); // Kuala Lumpur coordinates

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // POI layers (Hospitals, Schools by level, Worship, Rail types, Bus)
        const hospitalLayer = L.layerGroup();
        const kindergartenLayer = L.layerGroup();
        const primarySchoolLayer = L.layerGroup();
        const highSchoolLayer = L.layerGroup();
        const collegeLayer = L.layerGroup();
        const mosqueLayer = L.layerGroup();
        const churchLayer = L.layerGroup();
        const templeLayer = L.layerGroup();
        const otherWorshipLayer = L.layerGroup();
        const ktmRailLayer = L.layerGroup();
        const mrtRailLayer = L.layerGroup();
        const lrtRailLayer = L.layerGroup();
        const monorailLayer = L.layerGroup();
        const busLayer = L.layerGroup();    // Bus stops & bus stations

        let railDataLoaded = false;
        let schoolDataLoaded = false;
        let worshipDataLoaded = false;

        // Helper: build Overpass bbox string from current map view
        function getCurrentBBox() {
            const b = map.getBounds();
            // south,west,north,east
            return `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
        }

        // Helper: fetch POIs from Overpass API and add to a Leaflet layer group
        async function fetchAndRenderPOIs(overpassQuery, layer, defaultLabel, markerOptions) {
            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: overpassQuery
                });
                const data = await response.json();
                layer.clearLayers();

                if (!data.elements) return;

                data.elements.forEach(el => {
                    const lat = el.lat || (el.center && el.center.lat);
                    const lon = el.lon || (el.center && el.center.lon);
                    if (typeof lat !== 'number' || typeof lon !== 'number') return;

                    const tags = el.tags || {};
                    const name = tags.name || defaultLabel;

                    // Use custom emoji icons for Hospitals, Bus and Worship (to match POI legend)
                    let marker;
                    if (layer === hospitalLayer || layer === busLayer ||
                        layer === mosqueLayer || layer === churchLayer || layer === templeLayer || layer === otherWorshipLayer) {
                        let className = 'poi-amenity';
                        let emoji = '';

                        if (layer === hospitalLayer) {
                            className += ' poi-hospital';
                            emoji = '';
                        } else if (layer === busLayer) {
                            className += ' poi-bus';
                            emoji = '';
                        } else if (layer === mosqueLayer) {
                            className += ' poi-worship-mosque';
                            emoji = '';
                        } else if (layer === churchLayer) {
                            className += ' poi-worship-church';
                            emoji = '';
                        } else if (layer === templeLayer) {
                            className += ' poi-worship-temple';
                            emoji = '';
                        } else if (layer === otherWorshipLayer) {
                            className += ' poi-worship-other';
                            emoji = '';
                        }

                        const icon = L.divIcon({
                            className,
                            html: `<div class="poi-amenity-icon-inner">${emoji}</div>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });

                        marker = L.marker([lat, lon], { icon }).bindPopup(`<strong>${name}</strong>`);
                    } else {
                        // Fallback: use simple circle marker (e.g. for any future POI types)
                        marker = L.circleMarker([lat, lon], markerOptions)
                            .bindPopup(`<strong>${name}</strong>`);
                    }

                    layer.addLayer(marker);
                });

                if (!map.hasLayer(layer) && layer.getLayers().length > 0) {
                    layer.addTo(map);
                }
            } catch (err) {
                console.error('POI load error:', err);
            }
        }

        // Toggle handlers for POI switches
        async function toggleHospitals(checked) {
            if (!checked) {
                map.removeLayer(hospitalLayer);
                hospitalLayer.clearLayers();
                return;
            }

            const bbox = getCurrentBBox();
            const query = `
                [out:json][timeout:25];
                (
                  node["amenity"="hospital"](${bbox});
                  way["amenity"="hospital"](${bbox});
                  relation["amenity"="hospital"](${bbox});
                );
                out center;
            `;
            await fetchAndRenderPOIs(query, hospitalLayer, 'Hospital', {
                radius: 6,
                color: '#b91c1c',
                weight: 2,
                fillColor: '#ef4444',
                fillOpacity: 0.8
            });
        }

        // --- Schools (Kindergarten / Primary / Highschool / College) ---
        function classifySchoolType(tags) {
            const amenity = (tags.amenity || '').toLowerCase();
            const level = (tags['school:level'] || tags['isced:level'] || '').toLowerCase();
            const name = (tags.name || '').toLowerCase();

            if (amenity === 'kindergarten' || level.includes('preschool') || name.includes('kindergarten') || name.includes('tadika') || name.includes('taska')) {
                return 'kindergarten';
            }

            if (amenity === 'school') {
                if (level.includes('primary') || name.includes('primary') || name.includes('rendah')) {
                    return 'primary';
                }
                if (level.includes('secondary') || name.includes('secondary') || name.includes('high school') || name.includes('menengah')) {
                    return 'highschool';
                }
            }

            if (amenity === 'college' || amenity === 'university' ||
                name.includes('university') || name.includes('kolej') || name.includes('college') || name.includes('uni ')) {
                return 'college';
            }

            return null;
        }

        async function loadSchoolData() {
            if (schoolDataLoaded) return;
            schoolDataLoaded = true;

            const bbox = getCurrentBBox();
            try {
                const query = `
                    [out:json][timeout:25];
                    (
                      node["amenity"="school"](${bbox});
                      node["amenity"="kindergarten"](${bbox});
                      node["amenity"="college"](${bbox});
                      node["amenity"="university"](${bbox});
                    );
                    out body;
                `;
                const resp = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await resp.json();

                kindergartenLayer.clearLayers();
                primarySchoolLayer.clearLayers();
                highSchoolLayer.clearLayers();
                collegeLayer.clearLayers();

                if (!data.elements) return;

                data.elements.forEach(el => {
                    const lat = el.lat;
                    const lon = el.lon;
                    if (typeof lat !== 'number' || typeof lon !== 'number') return;

                    const tags = el.tags || {};
                    const type = classifySchoolType(tags);
                    if (!type) return;

                    const name = tags.name || 'School';

                    let layer;
                    let className = 'poi-amenity';
                    if (type === 'kindergarten') {
                        layer = kindergartenLayer;
                        className += ' poi-school-kindergarten';
                    } else if (type === 'primary') {
                        layer = primarySchoolLayer;
                        className += ' poi-school-primary';
                    } else if (type === 'highschool') {
                        layer = highSchoolLayer;
                        className += ' poi-school-high';
                    } else if (type === 'college') {
                        layer = collegeLayer;
                        className += ' poi-school-college';
                    } else {
                        return;
                    }

                    const icon = L.divIcon({
                        className,
                        html: `<div class="poi-amenity-icon-inner"></div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });

                    const marker = L.marker([lat, lon], { icon }).bindPopup(`<strong>${name}</strong>`);
                    layer.addLayer(marker);
                });
            } catch (err) {
                console.error('School data load error:', err);
            }
        }

        // --- Places of Worship (Mosque / Church / Temple / Other) ---
        function classifyWorshipType(tags) {
            const amenity = (tags.amenity || '').toLowerCase();
            const religion = (tags.religion || '').toLowerCase();
            const name = (tags.name || '').toLowerCase();

            if (amenity === 'place_of_worship' || amenity === 'worship') {
                if (religion === 'muslim' || religion === 'islam' || name.includes('masjid') || name.includes('surau')) {
                    return 'mosque';
                }
                if (religion === 'christian' || name.includes('church') || name.includes('chapel')) {
                    return 'church';
                }
                if (religion === 'buddhist' || religion === 'hindu' || religion === 'taoist' ||
                    name.includes('temple') || name.includes('vihara') || name.includes('kuil')) {
                    return 'temple';
                }
                return 'other';
            }
            return null;
        }

        async function loadWorshipData() {
            if (worshipDataLoaded) return;
            worshipDataLoaded = true;

            const bbox = getCurrentBBox();
            try {
                const query = `
                    [out:json][timeout:25];
                    (
                      node["amenity"="place_of_worship"](${bbox});
                    );
                    out body;
                `;
                const resp = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await resp.json();

                mosqueLayer.clearLayers();
                churchLayer.clearLayers();
                templeLayer.clearLayers();
                otherWorshipLayer.clearLayers();

                if (!data.elements) return;

                data.elements.forEach(el => {
                    const lat = el.lat;
                    const lon = el.lon;
                    if (typeof lat !== 'number' || typeof lon !== 'number') return;

                    const tags = el.tags || {};
                    const type = classifyWorshipType(tags);
                    if (!type) return;

                    const name = tags.name || 'Place of Worship';

                    let layer;
                    let className = 'poi-amenity';
                    let emoji = '';

                    if (type === 'mosque') {
                        layer = mosqueLayer;
                        className += ' poi-worship-mosque';
                        emoji = '';
                    } else if (type === 'church') {
                        layer = churchLayer;
                        className += ' poi-worship-church';
                        emoji = '';
                    } else if (type === 'temple') {
                        layer = templeLayer;
                        className += ' poi-worship-temple';
                        emoji = '';
                    } else if (type === 'other') {
                        layer = otherWorshipLayer;
                        className += ' poi-worship-other';
                        emoji = '';
                    } else {
                        return;
                    }

                    const icon = L.divIcon({
                        className,
                        html: `<div class="poi-amenity-icon-inner">${emoji}</div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });

                    const marker = L.marker([lat, lon], { icon }).bindPopup(`<strong>${name}</strong>`);
                    layer.addLayer(marker);
                });
            } catch (err) {
                console.error('Worship data load error:', err);
            }
        }

        // Helper: classify Malaysian rail type based on tags
        function classifyRailType(tags) {
            const name = (tags.name || '').toLowerCase();
            const network = (tags.network || '').toLowerCase();
            const operator = (tags.operator || '').toLowerCase();

            const text = `${name} ${network} ${operator}`;

            if (text.includes('ktm') || text.includes('keretapi tanah melayu')) {
                return 'ktm';
            }
            if (text.includes('mrt')) {
                return 'mrt';
            }
            if (text.includes('lrt')) {
                return 'lrt';
            }
            if (text.includes('monorail')) {
                return 'monorail';
            }
            return null;
        }

        // Load rail stations + lines once per current view, then toggles show/hide each type
        async function loadRailData() {
            if (railDataLoaded) return;
            railDataLoaded = true;

            const bbox = getCurrentBBox();

            try {
                // 1) Stations
                const stationQuery = `
                    [out:json][timeout:25];
                    (
                      node["public_transport"="station"](${bbox});
                      node["public_transport"="stop_position"](${bbox});
                      node["railway"~"station|stop|halt|subway_entrance|monorail"](${bbox});
                    );
                    out body;
                `;
                const stationResp = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: stationQuery
                });
                const stationData = await stationResp.json();

                // Clear any existing rail markers
                ktmRailLayer.clearLayers();
                mrtRailLayer.clearLayers();
                lrtRailLayer.clearLayers();
                monorailLayer.clearLayers();

                if (stationData.elements) {
                    stationData.elements.forEach(el => {
                        const lat = el.lat;
                        const lon = el.lon;
                        if (typeof lat !== 'number' || typeof lon !== 'number') return;

                        const tags = el.tags || {};
                        const type = classifyRailType(tags);
                        if (!type) return; // skip if we can't classify

                        const name = tags.name || 'Rail Station';

                        let layer, iconClass, emoji;
                        // Match icons with POI legend emojis
                        if (type === 'ktm') {
                            layer = ktmRailLayer;
                            iconClass = 'poi-rail-ktm';
                            emoji = '';
                        } else if (type === 'mrt') {
                            layer = mrtRailLayer;
                            iconClass = 'poi-rail-mrt';
                            emoji = '';
                        } else if (type === 'lrt') {
                            layer = lrtRailLayer;
                            iconClass = 'poi-rail-lrt';
                            emoji = '';
                        } else if (type === 'monorail') {
                            layer = monorailLayer;
                            iconClass = 'poi-rail-monorail';
                            emoji = '';
                        } else {
                            return;
                        }

                        const icon = L.divIcon({
                            className: `poi-rail-icon ${iconClass}`,
                            html: `<div class="poi-rail-icon-inner">${emoji}</div>`,
                            iconSize: [26, 26],
                            iconAnchor: [13, 13]
                        });

                        const marker = L.marker([lat, lon], { icon }).bindPopup(`<strong>${name}</strong>`);
                        layer.addLayer(marker);
                    });
                }

                // 2) Railway lines (tracks) with geometry
                const lineQuery = `
                    [out:json][timeout:25];
                    (
                      way["railway"~"rail|light_rail|subway|monorail"](${bbox});
                    );
                    out geom;
                `;
                const lineResp = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: lineQuery
                });
                const lineData = await lineResp.json();

                if (lineData.elements) {
                    lineData.elements.forEach(el => {
                        if (!el.geometry || !el.tags) return;
                        const tags = el.tags;
                        const type = classifyRailType(tags);
                        if (!type) return;

                        const latlngs = el.geometry.map(g => [g.lat, g.lon]);
                        let layer, color;
                        // Match line colors with station markers
                        if (type === 'ktm') {
                            layer = ktmRailLayer;
                            color = '#003b73';
                        } else if (type === 'mrt') {
                            layer = mrtRailLayer;
                            color = '#008b3e';
                        } else if (type === 'lrt') {
                            layer = lrtRailLayer;
                            color = '#c2143a';
                        } else if (type === 'monorail') {
                            layer = monorailLayer;
                            color = '#00838f';
                        } else {
                            return;
                        }

                        const polyline = L.polyline(latlngs, {
                            color,
                            weight: 3,
                            opacity: 0.9
                        });
                        layer.addLayer(polyline);
                    });
                }
            } catch (err) {
                console.error('Rail data load error:', err);
            }
        }

        // Individual school toggles
        async function toggleKindergarten(checked) {
            if (!checked) {
                map.removeLayer(kindergartenLayer);
                return;
            }
            await loadSchoolData();
            if (!map.hasLayer(kindergartenLayer) && kindergartenLayer.getLayers().length > 0) {
                kindergartenLayer.addTo(map);
            }
        }

        async function togglePrimary(checked) {
            if (!checked) {
                map.removeLayer(primarySchoolLayer);
                return;
            }
            await loadSchoolData();
            if (!map.hasLayer(primarySchoolLayer) && primarySchoolLayer.getLayers().length > 0) {
                primarySchoolLayer.addTo(map);
            }
        }

        async function toggleHighschool(checked) {
            if (!checked) {
                map.removeLayer(highSchoolLayer);
                return;
            }
            await loadSchoolData();
            if (!map.hasLayer(highSchoolLayer) && highSchoolLayer.getLayers().length > 0) {
                highSchoolLayer.addTo(map);
            }
        }

        async function toggleCollege(checked) {
            if (!checked) {
                map.removeLayer(collegeLayer);
                return;
            }
            await loadSchoolData();
            if (!map.hasLayer(collegeLayer) && collegeLayer.getLayers().length > 0) {
                collegeLayer.addTo(map);
            }
        }

        // Individual worship toggles
        async function toggleMosque(checked) {
            if (!checked) {
                map.removeLayer(mosqueLayer);
                return;
            }
            await loadWorshipData();
            if (!map.hasLayer(mosqueLayer) && mosqueLayer.getLayers().length > 0) {
                mosqueLayer.addTo(map);
            }
        }

        async function toggleChurch(checked) {
            if (!checked) {
                map.removeLayer(churchLayer);
                return;
            }
            await loadWorshipData();
            if (!map.hasLayer(churchLayer) && churchLayer.getLayers().length > 0) {
                churchLayer.addTo(map);
            }
        }

        async function toggleTemple(checked) {
            if (!checked) {
                map.removeLayer(templeLayer);
                return;
            }
            await loadWorshipData();
            if (!map.hasLayer(templeLayer) && templeLayer.getLayers().length > 0) {
                templeLayer.addTo(map);
            }
        }

        async function toggleOtherWorship(checked) {
            if (!checked) {
                map.removeLayer(otherWorshipLayer);
                return;
            }
            await loadWorshipData();
            if (!map.hasLayer(otherWorshipLayer) && otherWorshipLayer.getLayers().length > 0) {
                otherWorshipLayer.addTo(map);
            }
        }

        // Master Worship toggle: controls all worship types
        async function toggleWorship(checked) {
            const ms = document.getElementById('toggleMosque');
            const ch = document.getElementById('toggleChurch');
            const tp = document.getElementById('toggleTemple');
            const ot = document.getElementById('toggleOtherWorship');

            if (checked) {
                if (ms) ms.checked = true;
                if (ch) ch.checked = true;
                if (tp) tp.checked = true;
                if (ot) ot.checked = true;

                await toggleMosque(true);
                await toggleChurch(true);
                await toggleTemple(true);
                await toggleOtherWorship(true);
            } else {
                if (ms) ms.checked = false;
                if (ch) ch.checked = false;
                if (tp) tp.checked = false;
                if (ot) ot.checked = false;

                await toggleMosque(false);
                await toggleChurch(false);
                await toggleTemple(false);
                await toggleOtherWorship(false);
            }
        }

        // Master Schools toggle: controls all levels
        async function toggleSchools(checked) {
            const kg = document.getElementById('toggleKindergarten');
            const pr = document.getElementById('togglePrimary');
            const hs = document.getElementById('toggleHighschool');
            const co = document.getElementById('toggleCollege');

            if (checked) {
                if (kg) kg.checked = true;
                if (pr) pr.checked = true;
                if (hs) hs.checked = true;
                if (co) co.checked = true;

                await toggleKindergarten(true);
                await togglePrimary(true);
                await toggleHighschool(true);
                await toggleCollege(true);
            } else {
                if (kg) kg.checked = false;
                if (pr) pr.checked = false;
                if (hs) hs.checked = false;
                if (co) co.checked = false;

                await toggleKindergarten(false);
                await togglePrimary(false);
                await toggleHighschool(false);
                await toggleCollege(false);
            }
        }

        // Individual rail toggles just show/hide their layer; data is loaded once
        async function toggleKTM(checked) {
            if (!checked) {
                map.removeLayer(ktmRailLayer);
                return;
            }
            await loadRailData();
            if (!map.hasLayer(ktmRailLayer) && ktmRailLayer.getLayers().length > 0) {
                ktmRailLayer.addTo(map);
            }
        }

        async function toggleMRT(checked) {
            if (!checked) {
                map.removeLayer(mrtRailLayer);
                return;
            }
            await loadRailData();
            if (!map.hasLayer(mrtRailLayer) && mrtRailLayer.getLayers().length > 0) {
                mrtRailLayer.addTo(map);
            }
        }

        async function toggleLRT(checked) {
            if (!checked) {
                map.removeLayer(lrtRailLayer);
                return;
            }
            await loadRailData();
            if (!map.hasLayer(lrtRailLayer) && lrtRailLayer.getLayers().length > 0) {
                lrtRailLayer.addTo(map);
            }
        }

        async function toggleMonorail(checked) {
            if (!checked) {
                map.removeLayer(monorailLayer);
                return;
            }
            await loadRailData();
            if (!map.hasLayer(monorailLayer) && monorailLayer.getLayers().length > 0) {
                monorailLayer.addTo(map);
            }
        }

        // Master Trains toggle: turn all rail types on/off together
        async function toggleTrains(checked) {
            const ktmInput = document.getElementById('toggleKTM');
            const mrtInput = document.getElementById('toggleMRT');
            const lrtInput = document.getElementById('toggleLRT');
            const monorailInput = document.getElementById('toggleMonorail');

            if (checked) {
                if (ktmInput) ktmInput.checked = true;
                if (mrtInput) mrtInput.checked = true;
                if (lrtInput) lrtInput.checked = true;
                if (monorailInput) monorailInput.checked = true;

                await toggleKTM(true);
                await toggleMRT(true);
                await toggleLRT(true);
                await toggleMonorail(true);
            } else {
                if (ktmInput) ktmInput.checked = false;
                if (mrtInput) mrtInput.checked = false;
                if (lrtInput) lrtInput.checked = false;
                if (monorailInput) monorailInput.checked = false;

                await toggleKTM(false);
                await toggleMRT(false);
                await toggleLRT(false);
                await toggleMonorail(false);
            }
        }

        // Expand/collapse Trains child list
        function toggleTrainsDropdown() {
            const children = document.getElementById('trainChildren');
            const caret = document.getElementById('trainCaret');
            if (!children || !caret) return;

            const isOpen = children.classList.toggle('show');
            caret.textContent = isOpen ? '' : '';
        }

        function toggleSchoolsDropdown() {
            const children = document.getElementById('schoolsChildren');
            const caret = document.getElementById('schoolsCaret');
            if (!children || !caret) return;

            const isOpen = children.classList.toggle('show');
            caret.textContent = isOpen ? '' : '';
        }

        function toggleWorshipDropdown() {
            const children = document.getElementById('worshipChildren');
            const caret = document.getElementById('worshipCaret');
            if (!children || !caret) return;

            const isOpen = children.classList.toggle('show');
            caret.textContent = isOpen ? '' : '';
        }

        // Collapse / expand POI toggle panel on right side of map
        function togglePoiPanel() {
            const body = document.body;
            const arrow = document.getElementById('poiPanelToggleArrow');
            const collapsed = body.classList.toggle('poi-panel-collapsed');

            if (arrow) {
                // When panel is visible, arrow points right (collapse); when hidden, arrow points left (open)
                arrow.textContent = collapsed ? '' : '';
            }

            // Let Leaflet recalc size without changing center/zoom
            setTimeout(() => {
                if (typeof map !== 'undefined') {
                    map.invalidateSize();
                }
            }, 260);
        }

        // Collapse / expand search bar (hides to top)
        function toggleSearchBar() {
            const body = document.body;
            const searchControl = document.getElementById('mapSearchControl');
            const toggleTab = document.getElementById('searchToggleTab');
            const arrow = document.getElementById('searchToggleArrow');
            
            if (!searchControl || searchControl.classList.contains('hidden')) {
                // Search bar is hidden (not shown yet), don't toggle
                return;
            }

            const collapsed = body.classList.toggle('search-collapsed');

            if (collapsed) {
                // Collapse: add collapsed class to search control
                searchControl.classList.add('collapsed');
            } else {
                // Expand: remove collapsed class
                searchControl.classList.remove('collapsed');
            }

            // Arrow points down when expanded (to collapse), up when collapsed (to expand)
            if (arrow) {
                arrow.textContent = collapsed ? '' : '';
            }
        }

        // Bus: bus stops & bus stations
        async function toggleBus(checked) {
            if (!checked) {
                map.removeLayer(busLayer);
                busLayer.clearLayers();
                return;
            }

            const bbox = getCurrentBBox();
            const query = `
                [out:json][timeout:25];
                (
                  node["highway"="bus_stop"](${bbox});
                  node["amenity"="bus_station"](${bbox});
                  way["amenity"="bus_station"](${bbox});
                  relation["amenity"="bus_station"](${bbox});
                );
                out center;
            `;
            await fetchAndRenderPOIs(query, busLayer, 'Bus Stop', {
                radius: 5,
                color: '#7c2d12',
                weight: 2,
                fillColor: '#f97316',
                fillOpacity: 0.9
            });
        }

        // Map markers
        let locationMarkers = new Map(); // Map of locationId -> marker object
        let previewMarker = null; // Temporary marker for previewing new location
        let locationIdCounter = 0; // Counter for generating unique location IDs
        let pendingClickLocation = null;
        
        // Helper function to get first location (for backward compatibility with analysis functions)
        function getFirstLocation() {
            if (!questionnaireData.locations || questionnaireData.locations.length === 0) {
                return null;
            }
            return questionnaireData.locations[0];
        }
        let analysisCircles = []; // Concentric radius circles for Start Analysis
        let locationCirclesMap = new Map(); // Map of locationId -> array of circles for that location
        
        // Condo layers for each distance band
        const condoLayer0to3km = L.layerGroup();
        const condoLayer3to6km = L.layerGroup();
        const condoLayer6to9km = L.layerGroup();
        const condoLayer9to12km = L.layerGroup();
        let condoMarkers = []; // Store all condo markers for easy removal
        
        // Route layers for condo to work location
        let drivingRoute = null;
        let walkingRoute = null;
        let transitRoute = null;
        let currentCondoMarker = null;

        // Clear all routes
        function clearRoutes() {
            if (drivingRoute) {
                map.removeLayer(drivingRoute);
                drivingRoute = null;
            }
            if (walkingRoute) {
                map.removeLayer(walkingRoute);
                walkingRoute = null;
            }
            if (transitRoute) {
                map.removeLayer(transitRoute);
                transitRoute = null;
            }
            // Also clear Airbnb markers when routes are cleared
            clearAirbnbMarkers();
        }

        // Format duration in minutes
        function formatDuration(seconds) {
            const minutes = Math.round(seconds / 60);
            if (minutes < 60) {
                return `${minutes} min`;
            }
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours}h ${mins} min` : `${hours}h`;
        }

        // Format distance
        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)} m`;
            }
            return `${(meters / 1000).toFixed(1)} km`;
        }

        // Fetch route from OSRM API
        async function fetchRoute(start, end, profile) {
            try {
                const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    return {
                        distance: route.distance,
                        duration: route.duration,
                        geometry: route.geometry
                    };
                }
                return null;
            } catch (error) {
                console.error(`Error fetching ${profile} route:`, error);
                return null;
            }
        }

        // Display route on map
        function displayRoute(routeData, color, profile) {
            if (!routeData || !routeData.geometry) return null;
            
            const coordinates = routeData.geometry.coordinates.map(coord => [coord[1], coord[0]]);
            const polyline = L.polyline(coordinates, {
                color: color,
                weight: 4,
                opacity: 0.7,
                dashArray: profile === 'walking' ? '10, 10' : undefined
            }).addTo(map);
            
            return polyline;
        }

        // Show routes from condo to work location
        async function showRoutesToWork(condoLat, condoLng, condoName, condoElement = null, condoData = null) {
            const firstLocation = getFirstLocation();
            if (!firstLocation) {
                alert('Please pin at least one location first.');
                return;
            }

            // Clear previous routes and Airbnb markers
            clearRoutes();
            clearAirbnbMarkers();

            // Collapse all other condo items
            document.querySelectorAll('.condo-item.expanded').forEach(item => {
                if (item !== condoElement) {
                    item.classList.remove('expanded');
                }
            });

            const start = { lat: condoLat, lng: condoLng };
            const end = { lat: firstLocation.lat, lng: firstLocation.lng };

            // Show loading in sidebar if condo element is provided
            if (condoElement) {
                const detailsEl = condoElement.querySelector('.condo-item-details');
                if (detailsEl) {
                    detailsEl.innerHTML = '<div class="condo-loading-routes">Loading routes...</div>';
                    condoElement.classList.add('expanded');
                }
            }

            // Show loading message on map
            const loadingMsg = L.popup()
                .setLatLng([(condoLat + firstLocation.lat) / 2, (condoLng + firstLocation.lng) / 2])
                .setContent('<div style="text-align: center;"><div>Loading routes...</div></div>')
                .openOn(map);

            try {
                // Fetch all three routes in parallel
                const [drivingData, walkingData] = await Promise.all([
                    fetchRoute(start, end, 'driving'),
                    fetchRoute(start, end, 'walking')
                ]);

                // Remove loading message
                map.closePopup();

                // Calculate transit route (simplified)
                const transitDistance = calculateDistance(condoLat, condoLng, firstLocation.lat, firstLocation.lng);
                const transitDuration = Math.round(transitDistance / 1000 * 3); // Estimate 3 min per km for transit

                // Display routes on map
                let routeInfo = `<strong>${condoName}</strong><br><br>`;

                if (drivingData) {
                    drivingRoute = displayRoute(drivingData, '#3b82f6', 'driving');
                    routeInfo += `<strong> Driving:</strong> ${formatDistance(drivingData.distance)}  ${formatDuration(drivingData.duration)}<br>`;
                } else {
                    routeInfo += `<strong> Driving:</strong> Route not available<br>`;
                }

                if (walkingData) {
                    walkingRoute = displayRoute(walkingData, '#22c55e', 'walking');
                    routeInfo += `<strong> Walking:</strong> ${formatDistance(walkingData.distance)}  ${formatDuration(walkingData.duration)}<br>`;
                } else {
                    routeInfo += `<strong> Walking:</strong> Route not available<br>`;
                }

                // Create transit route on map
                const transitCoords = [
                    [condoLat, condoLng],
                    [firstLocation.lat, firstLocation.lng]
                ];
                transitRoute = L.polyline(transitCoords, {
                    color: '#8b5cf6',
                    weight: 4,
                    opacity: 0.7,
                    dashArray: '5, 5'
                }).addTo(map);
                
                routeInfo += `<strong> Public Transport:</strong> ${formatDistance(transitDistance)}  ~${formatDuration(transitDuration * 60)} (estimated)<br>`;

                // Update marker popup with route info
                if (currentCondoMarker) {
                    currentCondoMarker.setPopupContent(routeInfo);
                }

                // Plot nearby Airbnb listings (within 300m radius)
                plotAirbnbNearby(condoLat, condoLng);
                
                // Update budget max dropdown based on median asking sales price
                // Only update if budget was NOT set from questionnaire or manually (preserve user's choice)
                const sidebarBudgetMin = document.getElementById('sidebarBudgetMin');
                const sidebarBudgetMax = document.getElementById('sidebarBudgetMax');
                const hasMinBudget = (sidebarBudgetMin && sidebarBudgetMin.value && sidebarBudgetMin.value !== '') || 
                                     (questionnaireData.minBudget && questionnaireData.minBudget !== 'null' && questionnaireData.minBudget !== '');
                const hasMaxBudget = (sidebarBudgetMax && sidebarBudgetMax.value && sidebarBudgetMax.value !== '') || 
                                     (questionnaireData.maxBudget && questionnaireData.maxBudget !== 'null' && questionnaireData.maxBudget !== '');
                
                if (condoData && !hasMinBudget && !hasMaxBudget) {
                    updateBudgetMaxFromProperty(condoData);
                }
                
                // Update sidebar with route information and condo details
                if (condoElement) {
                    const detailsEl = condoElement.querySelector('.condo-item-details');
                    if (detailsEl) {
                        let detailsHtml = '';

                        // Always show condo property details section with all fields (show N/A if missing)
                        if (condoData) {
                            detailsHtml += '<div class="condo-property-info">';
                            
                            // Developer
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Developer</div>
                                    <div class="condo-property-value">${condoData.developer && condoData.developer.trim() ? condoData.developer : 'N/A'}</div>
                                </div>
                            `;

                            // Completion Year
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Completion Year</div>
                                    <div class="condo-property-value">${condoData.completionYear && condoData.completionYear.trim() ? condoData.completionYear : 'N/A'}</div>
                                </div>
                            `;

                            // Tenure
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Tenure</div>
                                    <div class="condo-property-value">${condoData.tenure && condoData.tenure.trim() ? condoData.tenure : 'N/A'}</div>
                                </div>
                            `;

                            // Number of Floors
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Number of Floors</div>
                                    <div class="condo-property-value">${condoData.numFloors && condoData.numFloors.trim() ? condoData.numFloors : 'N/A'}</div>
                                </div>
                            `;

                            // Number of Units
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Number of Units</div>
                                    <div class="condo-property-value">${condoData.numUnits && condoData.numUnits.trim() ? condoData.numUnits : 'N/A'}</div>
                                </div>
                            `;

                            detailsHtml += '</div>';
                        } else {
                            // If no condoData at all, still show the section with all N/A
                            detailsHtml += '<div class="condo-property-info">';
                            detailsHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Developer</div>
                                    <div class="condo-property-value">N/A</div>
                                </div>
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Completion Year</div>
                                    <div class="condo-property-value">N/A</div>
                                </div>
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Tenure</div>
                                    <div class="condo-property-value">N/A</div>
                                </div>
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Number of Floors</div>
                                    <div class="condo-property-value">N/A</div>
                                </div>
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Number of Units</div>
                                    <div class="condo-property-value">N/A</div>
                                </div>
                            `;
                            detailsHtml += '</div>';
                        }

                        // Add ads pricing information (Sale From and Rent From)
                        if (condoData) {
                            const propertyKey = generatePropertyKey(
                                condoData.negeri || '',
                                condoData.daerah || '',
                                condoData.mukim || '',
                                condoData.seksyen || '',
                                condoData.lot || ''
                            );
                            
                            const adsData = allAds.get(propertyKey);
                            
                            if (adsData && (adsData.minSalePrice !== null || adsData.minRentPrice !== null || (adsData.builtupValues && adsData.builtupValues.length > 0))) {
                                detailsHtml += '<div class="condo-property-info">';
                                
                                // Sale From
                                if (adsData.minSalePrice !== null) {
                                    const formattedSalePrice = adsData.minSalePrice.toLocaleString('en-US', {
                                        minimumFractionDigits: 2,
                                        maximumFractionDigits: 2
                                    });
                                    detailsHtml += `
                                        <div class="condo-property-item">
                                            <div class="condo-property-label"> Sale</div>
                                            <div class="condo-property-value">From RM ${formattedSalePrice}</div>
                                        </div>
                                    `;
                                }
                                
                                // Rent From
                                if (adsData.minRentPrice !== null) {
                                    const formattedRentPrice = adsData.minRentPrice.toLocaleString('en-US', {
                                        minimumFractionDigits: 2,
                                        maximumFractionDigits: 2
                                    });
                                    detailsHtml += `
                                        <div class="condo-property-item">
                                            <div class="condo-property-label"> Rent</div>
                                            <div class="condo-property-value">From RM ${formattedRentPrice}</div>
                                        </div>
                                    `;
                                }
                                
                                // Property Size (Minimum Built-up Area)
                                if (adsData.builtupValues && adsData.builtupValues.length > 0) {
                                    const minBuiltup = Math.min(...adsData.builtupValues);
                                    const formattedBuiltup = minBuiltup.toLocaleString('en-US', {
                                        minimumFractionDigits: 0,
                                        maximumFractionDigits: 0
                                    });
                                    detailsHtml += `
                                        <div class="condo-property-item">
                                            <div class="condo-property-label"> Property Size</div>
                                            <div class="condo-property-value">From ${formattedBuiltup} sqft</div>
                                        </div>
                                    `;
                                }
                                
                                detailsHtml += '</div>';
                            }
                        }

                        // Add route information
                        detailsHtml += '<div class="condo-route-info">';
                        
                        if (drivingData) {
                            detailsHtml += `
                                <div class="condo-route-item">
                                    <div class="condo-route-label"> Driving</div>
                                    <div class="condo-route-value">${formatDistance(drivingData.distance)}  ${formatDuration(drivingData.duration)}</div>
                                </div>
                            `;
                        } else {
                            detailsHtml += `
                                <div class="condo-route-item">
                                    <div class="condo-route-label"> Driving</div>
                                    <div class="condo-route-value">Not available</div>
                                </div>
                            `;
                        }

                        if (walkingData) {
                            detailsHtml += `
                                <div class="condo-route-item">
                                    <div class="condo-route-label"> Walking</div>
                                    <div class="condo-route-value">${formatDistance(walkingData.distance)}  ${formatDuration(walkingData.duration)}</div>
                                </div>
                            `;
                        } else {
                            detailsHtml += `
                                <div class="condo-route-item">
                                    <div class="condo-route-label"> Walking</div>
                                    <div class="condo-route-value">Not available</div>
                                </div>
                            `;
                        }

                        detailsHtml += `
                            <div class="condo-route-item">
                                <div class="condo-route-label"> Public Transport</div>
                                <div class="condo-route-value">${formatDistance(transitDistance)}  ~${formatDuration(transitDuration * 60)}</div>
                            </div>
                        `;

                        detailsHtml += '</div>';
                        
                        // Add View Details button at bottom with data attributes for analysis
                        const propertyKey = generatePropertyKey(
                            condoData.negeri || '',
                            condoData.daerah || '',
                            condoData.mukim || '',
                            condoData.seksyen || '',
                            condoData.lot || ''
                        );
                        
                        // Debug: Log property key generation
                        console.log('Condo property key:', propertyKey, {
                            negeri: condoData.negeri,
                            daerah: condoData.daerah,
                            mukim: condoData.mukim,
                            seksyen: condoData.seksyen,
                            lot: condoData.lot
                        });
                        
                        detailsHtml += `<button class="condo-view-details-btn" data-property-key="${propertyKey}" data-condo-name="${condoName}">View Details</button>`;
                        
                        detailsEl.innerHTML = detailsHtml;
                        
                        // Add click handler to View Details button
                        const viewDetailsBtn = detailsEl.querySelector('.condo-view-details-btn');
                        if (viewDetailsBtn) {
                            viewDetailsBtn.addEventListener('click', () => {
                                showPropertyAnalysis(propertyKey, condoName, condoLat, condoLng);
                            });
                        }
                    }
                }

            } catch (error) {
                console.error('Error fetching routes:', error);
                map.closePopup();
                
                if (condoElement) {
                    const detailsEl = condoElement.querySelector('.condo-item-details');
                    if (detailsEl) {
                        detailsEl.innerHTML = '<div class="condo-loading-routes">Failed to load routes</div>';
                    }
                }
                
                alert('Failed to load routes. Please try again.');
            }
        }

        // Property Analysis Functions
        function savePropertyAnalysis() {
            // Get the current property analysis data
            const modal = document.getElementById('propertyAnalysisModal');
            if (!modal) return;
            
            const propertyKey = modal.dataset.propertyKey;
            const condoName = modal.dataset.condoName;
            
            if (!propertyKey || !condoName) {
                alert('No property data to save.');
                return;
            }
            
            // TODO: Implement save functionality (e.g., save to localStorage, export to CSV, etc.)
            console.log('Saving property analysis:', { propertyKey, condoName });
            alert('Property analysis saved! (Functionality to be implemented)');
        }
        
        function showPropertyAnalysis(propertyKey, condoName, condoLat = null, condoLng = null) {
            // Debug: Log the property key and available keys
            console.log('Looking for property key:', propertyKey);
            console.log('Available transaction keys:', Array.from(pastTransactions.keys()));
            console.log('Total transactions loaded:', pastTransactions.size);
            
            if (!pastTransactions.has(propertyKey)) {
                // Try to find similar keys (for debugging)
                const similarKeys = Array.from(pastTransactions.keys()).filter(key => {
                    const keyParts = key.split('|');
                    const searchParts = propertyKey.split('|');
                    // Check if at least 3 parts match
                    let matches = 0;
                    for (let i = 0; i < Math.min(keyParts.length, searchParts.length); i++) {
                        if (keyParts[i] === searchParts[i] && keyParts[i] !== '') {
                            matches++;
                        }
                    }
                    return matches >= 3;
                });
                
                if (similarKeys.length > 0) {
                    console.log('Similar keys found:', similarKeys);
                }
                
                alert(`No past transaction data available for this property.\n\nProperty Key: ${propertyKey}\n\nPlease ensure the Negeri, Daerah, Mukim, Seksyen, and Lot values match between the condo CSV and past transaction CSV.`);
                return;
            }
            
            const transactions = pastTransactions.get(propertyKey);
            console.log('Found transactions:', transactions.length);
            console.log('Sample transaction:', transactions[0]);
            const analysisData = analyzeTransactions(transactions);
            console.log('Analysis data:', analysisData);
            console.log('Analysis data length:', analysisData.length);
            
            // Create or get modal
            let modal = document.getElementById('propertyAnalysisModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'propertyAnalysisModal';
                modal.className = 'property-analysis-modal';
                modal.innerHTML = `
                    <div class="property-analysis-content">
                        <div class="property-analysis-header">
                            <div class="property-analysis-title">Property Analysis</div>
                            <div class="property-analysis-header-actions">
                                <button class="property-analysis-save" onclick="savePropertyAnalysis()">Save</button>
                                <button class="property-analysis-close" onclick="document.getElementById('propertyAnalysisModal').classList.remove('show')"></button>
                            </div>
                        </div>
                        <div id="propertyAnalysisContent"></div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('show');
                    }
                });
            }
            
            // Update content - ensure we get the content element after modal is created
            const content = document.getElementById('propertyAnalysisContent');
            if (!content) {
                console.error('propertyAnalysisContent element not found!');
                return;
            }
            
            console.log('Content element found:', content);
            
            if (analysisData.length === 0) {
                console.log('No analysis data, showing no data message');
                content.innerHTML = '<div class="no-data-message">No transaction data available for this property.</div>';
            } else {
                console.log('Building content with', analysisData.length, 'rows');
                
                // Calculate median & average price psf by year for chart
                const chartData = calculateMedianPricePsfByYear(analysisData);
                const latest4Years = chartData.slice(-4); // Get latest 4 years (oldest -> newest)
                
                // Build content HTML with chart on top and table on bottom
                let contentHtml = `
                    <div style="margin-bottom: 1rem;">
                        <h3 style="font-size: 1.1rem; color: var(--text-dark); margin-bottom: 0.5rem;">${condoName}</h3>
                    </div>
                `;
                
                // Chart section (upper half)
                if (latest4Years.length > 0) {
                    contentHtml += `
                        <div class="property-analysis-chart-section">
                            <div class="property-analysis-chart-grid">
                                <div class="chart-panel">
                                    <div style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 1rem; color: var(--text-dark); margin-bottom: calc(0.5rem + 2px);">Median Price per Square Foot (Latest 4 Years)</h4>
                                    </div>
                                    <div class="property-analysis-chart">
                                        <div class="chart-container">
                                            <div class="chart-y-axis" id="chartMedianYAxis"></div>
                                            <div class="chart-bars" id="chartMedianBars"></div>
                                        </div>
                                        <div class="chart-x-axis">Year</div>
                                    </div>
                                    <div class="boxplot-section">
                                        <div class="boxplot-title">Price per Square Foot Distribution (Box &amp; Whisker)</div>
                                        <div class="boxplot-x-axis" id="boxPsfXAxis-1"></div>
                                        <div class="boxplot-x-axis" id="boxPsfXAxis-2"></div>
                                        <div class="boxplot-container">
                                            <div class="boxplot-plot" id="boxPsfPlot"></div>
                                        </div>
                                        <div class="boxplot-x-axis" id="boxPsfXAxis-3"></div>
                                        <div class="boxplot-x-axis" id="boxPsfXAxis-4"></div>
                                        <div class="boxplot-label">Price per Square Foot (RM)</div>
                                    </div>
                                    <div class="histogram-section">
                                        <div class="histogram-title">Asking Sale Price per Square Foot</div>
                                        <div class="histogram-container">
                                            <div class="histogram-y-axis" id="histSalePsfYAxis"></div>
                                            <div class="histogram-bars" id="histSalePsfBars"></div>
                                        </div>
                                        <div class="histogram-x-axis">Price per Square Foot (RM)</div>
                                    </div>
                                </div>
                                <div class="chart-panel">
                                    <div style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 1rem; color: var(--text-dark); margin-bottom: calc(0.5rem + 2px);">Average Price per Square Foot (Latest 4 Years)</h4>
                                    </div>
                                    <div class="property-analysis-chart">
                                        <div class="chart-container">
                                            <div class="chart-y-axis" id="chartAvgYAxis"></div>
                                            <div class="chart-bars" id="chartAvgBars"></div>
                                        </div>
                                        <div class="chart-x-axis">Year</div>
                                    </div>
                                    <div class="boxplot-section">
                                        <div class="boxplot-title">Transacted Price Distribution (Box &amp; Whisker)</div>
                                        <div class="boxplot-x-axis" id="boxPriceXAxis-1"></div>
                                        <div class="boxplot-x-axis" id="boxPriceXAxis-2"></div>
                                        <div class="boxplot-container">
                                            <div class="boxplot-plot" id="boxPricePlot"></div>
                                        </div>
                                        <div class="boxplot-x-axis" id="boxPriceXAxis-3"></div>
                                        <div class="boxplot-x-axis" id="boxPriceXAxis-4"></div>
                                        <div class="boxplot-label">Transacted Price (RM)</div>
                                    </div>
                                    <div class="histogram-section">
                                        <div class="histogram-title">Asking Rent Price per Square Foot</div>
                                        <div class="histogram-container">
                                            <div class="histogram-y-axis" id="histRentPsfYAxis"></div>
                                            <div class="histogram-bars" id="histRentPsfBars"></div>
                                        </div>
                                        <div class="histogram-x-axis">Price per Square Foot (RM)</div>
                                    </div>
                                </div>
                            </div>
                            <div class="investment-score-section">
                                <div class="investment-score-main-title">Investment Score</div>
                                <div class="investment-score-subtitle">Appreciation Rate</div>
                                <div class="investment-score-bar">
                                    <div class="investment-score-segment bad" id="appScoreBad">Weak</div>
                                    <div class="investment-score-segment normal" id="appScoreNormal">Moderate</div>
                                    <div class="investment-score-segment good" id="appScoreGood">Strong</div>
                                </div>
                                <div class="investment-score-meta">
                                    <div>Average annual appreciation: <strong id="appreciationScoreValue">N/A</strong></div>
                                    <div id="appreciationScoreLabel"></div>
                                </div>
                                <div class="investment-score-subtitle" style="margin-top: 1.5rem;">Long-term ROI</div>
                                <div class="investment-score-bar">
                                    <div class="investment-score-segment bad" id="ltRoiScoreBad">Weak</div>
                                    <div class="investment-score-segment normal" id="ltRoiScoreNormal">Moderate</div>
                                    <div class="investment-score-segment good" id="ltRoiScoreGood">Strong</div>
                                </div>
                                <div class="investment-score-meta">
                                    <div>Long-term ROI: <strong id="ltRoiScoreValue">N/A</strong></div>
                                    <div id="ltRoiScoreLabel"></div>
                                </div>
                                <div class="investment-score-subtitle" style="margin-top: 1.5rem;">Short-term ROI</div>
                                <div class="investment-score-bar">
                                    <div class="investment-score-segment bad" id="stRoiScoreBad">Weak</div>
                                    <div class="investment-score-segment normal" id="stRoiScoreNormal">Moderate</div>
                                    <div class="investment-score-segment good" id="stRoiScoreGood">Strong</div>
                                </div>
                                <div class="investment-score-meta">
                                    <div>Short-term ROI: <strong id="stRoiScoreValue">N/A</strong></div>
                                    <div id="stRoiScoreLabel"></div>
                                </div>
                            </div>
                            <div class="analysis-summary-section">
                                <div class="analysis-summary-title">Analysis Summary</div>
                                <div class="analysis-summary-content" id="analysisSummaryContent">
                                    Explain all the chart and investment score using AI
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // Table section (lower half) - Past Transactions
                contentHtml += `
                    <div class="property-analysis-table-section">
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 1rem; color: var(--text-dark); margin-bottom: 0.5rem;">Past Transaction History</h4>
                        </div>
                        <div class="property-analysis-table-container">
                            <table class="property-analysis-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Transacted Price (RM)</th>
                                        <th>Build Up</th>
                                        <th>Address</th>
                                        <th>Price psf</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                analysisData.forEach(row => {
                    contentHtml += `
                        <tr>
                            <td>${row.date}</td>
                            <td>${row.transactedPrice}</td>
                            <td>${row.landArea}</td>
                            <td>${row.address}</td>
                            <td>${row.landAreaPsf}</td>
                        </tr>
                    `;
                });
                
                contentHtml += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                
                console.log('Setting content.innerHTML');
                content.innerHTML = contentHtml;
                
                // Render charts if we have data
                if (latest4Years.length > 0) {
                    setTimeout(() => {
                        // Median chart
                        renderBarChart(latest4Years, {
                            metricKey: 'medianPricePsf',
                            barsId: 'chartMedianBars',
                            yAxisId: 'chartMedianYAxis',
                            barClass: 'bar-median'
                        });
                        // Average chart
                        renderBarChart(latest4Years, {
                            metricKey: 'averagePricePsf',
                            barsId: 'chartAvgBars',
                            yAxisId: 'chartAvgYAxis',
                            barClass: 'bar-average'
                        });
                        
                        // Box & whisker for price per square foot (all transactions)
                        const psfValues = extractNumericArrayFromTable(analysisData, 'psf');
                        if (psfValues.length > 0) {
                            renderBoxPlot(psfValues, {
                                plotId: 'boxPsfPlot',
                                xAxisQ1Q3Id: 'boxPsfXAxis-1',
                                xAxisMeanId: 'boxPsfXAxis-2',
                                xAxisMedianId: 'boxPsfXAxis-3',
                                xAxisMinMaxId: 'boxPsfXAxis-4',
                                labelPrefix: 'psf',
                                isPricePsf: true
                            });
                        }
                        
                        // Box & whisker for transacted price (all transactions)
                        const priceValues = extractNumericArrayFromTable(analysisData, 'price');
                        if (priceValues.length > 0) {
                            renderBoxPlot(priceValues, {
                                plotId: 'boxPricePlot',
                                xAxisQ1Q3Id: 'boxPriceXAxis-1',
                                xAxisMeanId: 'boxPriceXAxis-2',
                                xAxisMedianId: 'boxPriceXAxis-3',
                                xAxisMinMaxId: 'boxPriceXAxis-4',
                                labelPrefix: 'price',
                                isPricePsf: false
                            });
                        }

                        // Current market histograms from All Ads (asking price psf)
                        if (allAds && allAds.has(propertyKey)) {
                            const adsEntry = allAds.get(propertyKey);
                            
                            // Sale psf histogram
                            if (adsEntry.salePsfValues && adsEntry.salePsfValues.length > 0) {
                                const saleBins = buildHistogram(adsEntry.salePsfValues, 8);
                                renderPriceHistogram(saleBins, {
                                    barsId: 'histSalePsfBars',
                                    yAxisId: 'histSalePsfYAxis',
                                    isPsf: true
                                });
                            }
                            
                            // Rent psf histogram
                            if (adsEntry.rentPsfValues && adsEntry.rentPsfValues.length > 0) {
                                const rentBins = buildHistogram(adsEntry.rentPsfValues, 8);
                                renderPriceHistogram(rentBins, {
                                    barsId: 'histRentPsfBars',
                                    yAxisId: 'histRentPsfYAxis',
                                    isPsf: true
                                });
                            }
                        }

                        // Appreciation rate score (based on median price psf of the same years shown in the chart)
                        const appreciationRate = calculateAppreciationRate(latest4Years);
                        if (typeof appreciationRate === 'number' && !isNaN(appreciationRate)) {
                            const valueEl = document.getElementById('appreciationScoreValue');
                            const labelEl = document.getElementById('appreciationScoreLabel');
                            const badEl = document.getElementById('appScoreBad');
                            const normalEl = document.getElementById('appScoreNormal');
                            const goodEl = document.getElementById('appScoreGood');
                            
                            const formatted = `${appreciationRate.toFixed(2)}% / year`;
                            if (valueEl) valueEl.textContent = formatted;
                            
                            // 3level scoring thresholds:
                            // Weak  < 3%
                            // Moderate 3% - 5.99%
                            // Strong >= 6%
                            let level = 'normal';
                            if (appreciationRate < 3) {
                                level = 'bad';
                            } else if (appreciationRate >= 6) {
                                level = 'good';
                            }
                            
                            let labelText = '';
                            if (level === 'bad') labelText = 'Weak appreciation (< 3% per year)';
                            if (level === 'normal') labelText = 'Moderate appreciation (3% - 5.99% per year)';
                            if (level === 'good') labelText = 'Strong appreciation ( 6% per year)';
                            if (labelEl) labelEl.textContent = labelText;
                            
                            [badEl, normalEl, goodEl].forEach(el => {
                                if (!el) return;
                                el.classList.remove('active');
                            });
                            if (level === 'bad' && badEl) badEl.classList.add('active');
                            if (level === 'normal' && normalEl) normalEl.classList.add('active');
                            if (level === 'good' && goodEl) goodEl.classList.add('active');
                        }
                        
                        // Long-term ROI score (based on All_Ads median rent and sale psf)
                        if (allAds && allAds.has(propertyKey)) {
                            const adsEntry = allAds.get(propertyKey);
                            const longTermROI = calculateLongTermROI(adsEntry);
                            
                            if (typeof longTermROI === 'number' && !isNaN(longTermROI)) {
                                const valueEl = document.getElementById('ltRoiScoreValue');
                                const labelEl = document.getElementById('ltRoiScoreLabel');
                                const badEl = document.getElementById('ltRoiScoreBad');
                                const normalEl = document.getElementById('ltRoiScoreNormal');
                                const goodEl = document.getElementById('ltRoiScoreGood');
                                
                                const formatted = `${longTermROI.toFixed(2)}%`;
                                if (valueEl) valueEl.textContent = formatted;
                                
                                // 3level scoring thresholds:
                                // Weak  < 3.5%
                                // Moderate 3.5% - < 4.99%
                                // Strong >= 5%
                                let level = 'normal';
                                if (longTermROI < 3.5) {
                                    level = 'bad';
                                } else if (longTermROI >= 5) {
                                    level = 'good';
                                }
                                
                                let labelText = '';
                                if (level === 'bad') labelText = 'Weak ROI (< 3.5%)';
                                if (level === 'normal') labelText = 'Moderate ROI (3.5% - 4.99%)';
                                if (level === 'good') labelText = 'Strong ROI ( 5%)';
                                if (labelEl) labelEl.textContent = labelText;
                                
                                [badEl, normalEl, goodEl].forEach(el => {
                                    if (!el) return;
                                    el.classList.remove('active');
                                });
                                if (level === 'bad' && badEl) badEl.classList.add('active');
                                if (level === 'normal' && normalEl) normalEl.classList.add('active');
                                if (level === 'good' && goodEl) goodEl.classList.add('active');
                            }
                        }
                        
                        // Short-term ROI score (based on Airbnb rental potential)
                        if (allAds && allAds.has(propertyKey) && condoLat !== null && condoLng !== null) {
                            const adsEntry = allAds.get(propertyKey);
                            const shortTermROI = calculateShortTermROI(adsEntry, condoLat, condoLng);
                            
                            const valueEl = document.getElementById('stRoiScoreValue');
                            const labelEl = document.getElementById('stRoiScoreLabel');
                            const badEl = document.getElementById('stRoiScoreBad');
                            const normalEl = document.getElementById('stRoiScoreNormal');
                            const goodEl = document.getElementById('stRoiScoreGood');
                            
                            // Treat null/invalid ROI as 0% (insufficient Airbnb data - 5 listings within 300m)
                            const displayROI = (shortTermROI !== null && !isNaN(shortTermROI)) ? shortTermROI : 0;
                            
                            const formatted = `${displayROI.toFixed(2)}%`;
                            if (valueEl) valueEl.textContent = formatted;
                            
                            // 3level scoring thresholds:
                            // Weak  < 4%
                            // Moderate 4% - 7.99%
                            // Strong >= 8%
                            let level = 'normal';
                            if (displayROI < 4) {
                                level = 'bad';
                            } else if (displayROI >= 8) {
                                level = 'good';
                            }
                            
                            let labelText = '';
                            if (shortTermROI === null || isNaN(shortTermROI)) {
                                // Insufficient data - treated as 0%
                                labelText = 'Insufficient data (5 listings within 300m) - Treated as 0%';
                            } else {
                                if (level === 'bad') labelText = 'Weak ROI (< 4%)';
                                if (level === 'normal') labelText = 'Moderate ROI (4% - 7.99%)';
                                if (level === 'good') labelText = 'Strong ROI ( 8%)';
                            }
                            if (labelEl) labelEl.textContent = labelText;
                            
                            [badEl, normalEl, goodEl].forEach(el => {
                                if (!el) return;
                                el.classList.remove('active');
                            });
                            if (level === 'bad' && badEl) badEl.classList.add('active');
                            if (level === 'normal' && normalEl) normalEl.classList.add('active');
                            if (level === 'good' && goodEl) goodEl.classList.add('active');
                        }
                    }, 100); // Small delay to ensure DOM is ready
                }
                
                console.log('Content innerHTML set, content.children.length:', content.children.length);
            }
            
            console.log('Showing modal');
            // Store property data in modal dataset for save function
            modal.dataset.propertyKey = propertyKey;
            modal.dataset.condoName = condoName;
            
            modal.classList.add('show');
        }
        
        function analyzeTransactions(transactions) {
            // Process all transactions and extract relevant data for table
            const tableData = [];
            
            transactions.forEach((transaction, index) => {
                // Find full date from "Date" column (format: "18 November 2024")
                let date = 'N/A';
                let year = null;
                
                // Look for "date" field (case-insensitive) - try exact match first
                let dateField = Object.keys(transaction).find(key => 
                    key.toLowerCase() === 'date'
                );
                
                // If not found, try variations
                if (!dateField) {
                    dateField = Object.keys(transaction).find(key => 
                        key.toLowerCase().includes('date')
                    );
                }
                
                // Debug first transaction only
                if (index === 0) {
                    console.log('First transaction - All keys:', Object.keys(transaction));
                    console.log('Date field found:', dateField);
                    if (dateField) {
                        console.log('Date value:', transaction[dateField]);
                    }
                }
                
                if (dateField && transaction[dateField]) {
                    const dateStr = transaction[dateField].toString().trim();
                    if (dateStr && dateStr !== '' && dateStr !== 'null' && dateStr !== 'undefined') {
                        date = dateStr;
                        // Also extract year for sorting
                        const yearMatch = dateStr.match(/\b(19|20)\d{2}\b/);
                        if (yearMatch) {
                            year = parseInt(yearMatch[0]);
                        }
                    }
                }
                
                // Find "Transacted Price (RM)" column
                const transactedPriceField = Object.keys(transaction).find(key => {
                    const keyLower = key.toLowerCase().replace(/\s+/g, ' ').trim();
                    return keyLower === 'transacted price (rm)' || 
                           keyLower === 'transacted price(rm)' ||
                           keyLower === 'transacted price' ||
                           keyLower === 'price (rm)' ||
                           keyLower === 'price(rm)';
                });
                
                // Find "Land Area" column (without psf)
                const landAreaField = Object.keys(transaction).find(key => {
                    const keyLower = key.toLowerCase().replace(/\s+/g, ' ').trim();
                    return keyLower === 'land area (sf)' || 
                           keyLower === 'land area(sf)' ||
                           keyLower === 'land area' ||
                           keyLower === 'landarea (sf)' ||
                           keyLower === 'landarea(sf)';
                });
                
                // Find "Address" column
                const addressField = Object.keys(transaction).find(key => 
                    key.toLowerCase() === 'address'
                );
                
                // Find "Land Area (psf)" column
                const landAreaPsfField = Object.keys(transaction).find(key => {
                    const keyLower = key.toLowerCase().replace(/\s+/g, ' ').trim();
                    return keyLower === 'land area (psf)' || 
                           keyLower === 'land area(psf)' ||
                           keyLower === 'land area psf' ||
                           keyLower === 'landarea(psf)' ||
                           keyLower === 'landarea (psf)';
                });
                
                // Extract values
                let transactedPrice = 'N/A';
                if (transactedPriceField && transaction[transactedPriceField]) {
                    const priceStr = transaction[transactedPriceField].toString().trim();
                    if (priceStr && priceStr !== '') {
                        // Remove any non-numeric characters except decimal point
                        const numericPrice = priceStr.replace(/[^0-9.]/g, '');
                        const priceNum = parseFloat(numericPrice);
                        if (!isNaN(priceNum) && priceNum > 0) {
                            // Format with thousand separators and 2 decimal places
                            transactedPrice = priceNum.toLocaleString('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2
                            });
                        } else {
                            transactedPrice = priceStr; // Keep original if can't parse
                        }
                    }
                }
                
                const landArea = landAreaField && transaction[landAreaField] 
                    ? transaction[landAreaField].toString().trim() 
                    : 'N/A';
                
                const address = addressField && transaction[addressField] 
                    ? transaction[addressField].toString().trim() 
                    : 'N/A';
                
                const landAreaPsf = landAreaPsfField && transaction[landAreaPsfField] 
                    ? transaction[landAreaPsfField].toString().trim() 
                    : 'N/A';
                
                // Add all transactions (even if date/year is missing)
                tableData.push({
                    date: date,
                    year: year, // Keep year for sorting
                    transactedPrice: transactedPrice,
                    landArea: landArea,
                    address: address,
                    landAreaPsf: landAreaPsf
                });
            });
            
            // Sort by year (newest first), but put N/A years at the end
            tableData.sort((a, b) => {
                if (!a.year) return 1;
                if (!b.year) return -1;
                if (typeof a.year === 'number' && typeof b.year === 'number') {
                    return b.year - a.year;
                }
                return 0;
            });
            
            console.log('Table data processed:', tableData.length, 'rows');
            if (tableData.length > 0) {
                console.log('First row sample:', tableData[0]);
            }
            return tableData;
        }
        
        function calculateMedianPricePsfByYear(tableData) {
            // Group transactions by year and collect all price psf values
            const yearData = {};
            
            tableData.forEach(row => {
                if (row.year && typeof row.year === 'number') {
                    // Parse price psf - handle formatted strings like "1,234.56" or "1234.56"
                    const pricePsfStr = row.landAreaPsf ? row.landAreaPsf.toString().replace(/[^0-9.]/g, '') : '';
                    const pricePsf = parseFloat(pricePsfStr);
                    
                    if (!isNaN(pricePsf) && pricePsf > 0) {
                        if (!yearData[row.year]) {
                            yearData[row.year] = [];
                        }
                        yearData[row.year].push(pricePsf);
                    }
                }
            });
            
            // Calculate median and average for each year
            const result = Object.keys(yearData)
                .map(year => {
                    const prices = yearData[year].sort((a, b) => a - b);
                    const median = prices.length % 2 === 0
                        ? (prices[prices.length / 2 - 1] + prices[prices.length / 2]) / 2
                        : prices[Math.floor(prices.length / 2)];
                    
                    const sum = prices.reduce((acc, v) => acc + v, 0);
                    const average = sum / prices.length;
                    
                    return {
                        year: parseInt(year, 10),
                        medianPricePsf: median,
                        averagePricePsf: average,
                        count: prices.length
                    };
                })
                // Sort oldest -> newest so X-axis runs left (oldest) to right (newest)
                .sort((a, b) => a.year - b.year);
            
            return result;
        }

        // Calculate Long-term ROI (%) from All_Ads data
        // Formula: (Median Rent psf  12 months) / Median Sale psf  100%
        function calculateLongTermROI(adsEntry) {
            if (!adsEntry) return null;
            
            const rentPsfValues = adsEntry.rentPsfValues || [];
            const salePsfValues = adsEntry.salePsfValues || [];
            
            if (rentPsfValues.length === 0 || salePsfValues.length === 0) return null;
            
            // Calculate median for rent psf
            const sortedRent = rentPsfValues.slice().sort((a, b) => a - b);
            const medianRentPsf = sortedRent.length % 2 === 0
                ? (sortedRent[sortedRent.length / 2 - 1] + sortedRent[sortedRent.length / 2]) / 2
                : sortedRent[Math.floor(sortedRent.length / 2)];
            
            // Calculate median for sale psf
            const sortedSale = salePsfValues.slice().sort((a, b) => a - b);
            const medianSalePsf = sortedSale.length % 2 === 0
                ? (sortedSale[sortedSale.length / 2 - 1] + sortedSale[sortedSale.length / 2]) / 2
                : sortedSale[Math.floor(sortedSale.length / 2)];
            
            if (medianSalePsf <= 0) return null;
            
            // Long-term ROI = (Annual Rent psf) / Sale psf  100%
            const annualRentPsf = medianRentPsf * 12;
            const roi = (annualRentPsf / medianSalePsf) * 100;
            
            return roi;
        }
        
        // Calculate median value from an array
        function calculateMedian(values) {
            if (!values || values.length === 0) return null;
            const sorted = values.slice().sort((a, b) => a - b);
            return sorted.length % 2 === 0
                ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                : sorted[Math.floor(sorted.length / 2)];
        }
        
        // Update budget max dropdown based on median asking sales price of selected property
        function updateBudgetMaxFromProperty(condoData) {
            if (!condoData) return;
            
            // Don't update if budget was set from questionnaire or manually by user (preserve user's choice)
            const sidebarBudgetMinEl = document.getElementById('sidebarBudgetMin');
            const sidebarBudgetMaxEl = document.getElementById('sidebarBudgetMax');
            const hasMinBudget = (sidebarBudgetMinEl && sidebarBudgetMinEl.value && sidebarBudgetMinEl.value !== '') || 
                                 (questionnaireData.minBudget && questionnaireData.minBudget !== 'null' && questionnaireData.minBudget !== '');
            const hasMaxBudget = (sidebarBudgetMaxEl && sidebarBudgetMaxEl.value && sidebarBudgetMaxEl.value !== '') || 
                                 (questionnaireData.maxBudget && questionnaireData.maxBudget !== 'null' && questionnaireData.maxBudget !== '');
            
            if (hasMinBudget || hasMaxBudget) {
                console.log('Budget was set by user (from questionnaire or manually), preserving user value');
                return;
            }
            
            const propertyKey = generatePropertyKey(
                condoData.negeri || '',
                condoData.daerah || '',
                condoData.mukim || '',
                condoData.seksyen || '',
                condoData.lot || ''
            );
            
            if (!sidebarBudgetMaxEl) return;
            
            // Get median asking sales price from All_Ads
            let medianSalePrice = null;
            if (allAds && allAds.has(propertyKey)) {
                const adsEntry = allAds.get(propertyKey);
                const salePrices = adsEntry.salePrices || [];
                if (salePrices.length > 0) {
                    medianSalePrice = calculateMedian(salePrices);
                }
            }
            
            if (!medianSalePrice || medianSalePrice <= 0) {
                // If no median price available, restore all options
                restoreBudgetMaxOptions();
                return;
            }
            
            // Round up to nearest 100k for cleaner display
            const maxBudget = Math.ceil(medianSalePrice / 100000) * 100000;
            
            // Store current selection
            const currentValue = sidebarBudgetMaxEl.value;
            
            // Remove all options except "Max"
            sidebarBudgetMaxEl.innerHTML = '<option value="">Max</option>';
            
            // Add options up to the median price (rounded up)
            const budgetOptions = [
                100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000,
                1000000, 1100000, 1200000, 1300000, 1400000, 1500000, 1600000, 1700000, 1800000, 1900000,
                2000000, 2100000, 2200000, 2300000, 2400000, 2500000, 2600000, 2700000, 2800000, 2900000,
                3000000, 3500000, 4000000, 4500000, 5000000, 5500000, 6000000, 6500000, 7000000, 7500000,
                8000000, 8500000, 9000000, 9500000, 10000000
            ];
            
            budgetOptions.forEach(optionValue => {
                if (optionValue <= maxBudget) {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    if (optionValue < 1000000) {
                        option.textContent = `RM ${(optionValue / 1000).toFixed(0)}k`;
                    } else {
                        option.textContent = `RM ${(optionValue / 1000000).toFixed(1)}M`;
                    }
                    sidebarBudgetMaxEl.appendChild(option);
                }
            });
            
            // Restore previous selection if it's still valid, otherwise set to max available
            if (currentValue && parseInt(currentValue) <= maxBudget) {
                sidebarBudgetMaxEl.value = currentValue;
            } else if (sidebarBudgetMaxEl.options.length > 1) {
                // Set to the highest available option
                const lastOption = sidebarBudgetMaxEl.options[sidebarBudgetMaxEl.options.length - 1];
                sidebarBudgetMaxEl.value = lastOption.value;
                questionnaireData.maxBudget = lastOption.value;
            }
        }
        
        // Restore all budget max options (when no property is selected)
        function restoreBudgetMaxOptions() {
            const sidebarBudgetMax = document.getElementById('sidebarBudgetMax');
            if (!sidebarBudgetMax) return;
            
            const currentValue = sidebarBudgetMax.value;
            
            sidebarBudgetMax.innerHTML = `
                <option value="">Max</option>
                <option value="100000">RM 100,000</option>
                <option value="200000">RM 200,000</option>
                <option value="300000">RM 300,000</option>
                <option value="400000">RM 400,000</option>
                <option value="500000">RM 500,000</option>
                <option value="600000">RM 600,000</option>
                <option value="700000">RM 700,000</option>
                <option value="800000">RM 800,000</option>
                <option value="900000">RM 900,000</option>
                <option value="1000000">RM 1,000,000</option>
                <option value="1100000">RM 1,100,000</option>
                <option value="1200000">RM 1,200,000</option>
                <option value="1300000">RM 1,300,000</option>
                <option value="1400000">RM 1,400,000</option>
                <option value="1500000">RM 1,500,000</option>
                <option value="1600000">RM 1,600,000</option>
                <option value="1700000">RM 1,700,000</option>
                <option value="1800000">RM 1,800,000</option>
                <option value="1900000">RM 1,900,000</option>
                <option value="2000000">RM 2,000,000</option>
                <option value="2100000">RM 2,100,000</option>
                <option value="2200000">RM 2,200,000</option>
                <option value="2300000">RM 2,300,000</option>
                <option value="2400000">RM 2,400,000</option>
                <option value="2500000">RM 2,500,000</option>
                <option value="2600000">RM 2,600,000</option>
                <option value="2700000">RM 2,700,000</option>
                <option value="2800000">RM 2,800,000</option>
                <option value="2900000">RM 2,900,000</option>
                <option value="3000000">RM 3,000,000</option>
                <option value="3100000">RM 3,500,000</option>
                <option value="3200000">RM 4,000,000</option>
                <option value="3300000">RM 4,500,000</option>
                <option value="3400000">RM 5,000,000</option>
                <option value="3500000">RM 5,500,000</option>
                <option value="3600000">RM 6,000,000</option>
                <option value="3700000">RM 6,500,000</option>
                <option value="3800000">RM 7,000,000</option>
                <option value="3900000">RM 7,500,000</option>
                <option value="4000000">RM 8,000,000</option>
                <option value="4100000">RM 8,500,000</option>
                <option value="4200000">RM 9,000,000</option>
                <option value="4300000">RM 9,500,000</option>
                <option value="4400000">RM 10,000,000</option>
            `;
            
            if (currentValue) {
                sidebarBudgetMax.value = currentValue;
            }
        }
        
        // Get median price per night from Airbnb listings within 300m radius
        // Returns null if there are 5 or fewer listings (considered insufficient data / area may not allow Airbnb)
        function getMedianAirbnbPricePerNight(centerLat, centerLon) {
            if (!airbnbListings || airbnbListings.length === 0) return null;
            
            // Filter listings within 300m radius
            const nearbyListings = airbnbListings.filter(listing => {
                const distance = calculateDistance(centerLat, centerLon, listing.lat, listing.lon);
                return distance <= 300; // 300 meters
            });
            
            if (nearbyListings.length === 0) return null;
            
            // If there are 5 or fewer listings, return null (N/A) - area may not allow Airbnb
            if (nearbyListings.length <= 5) return null;
            
            const prices = nearbyListings.map(listing => listing.pricePerNight);
            return calculateMedian(prices);
        }
        
        // Calculate Short-term ROI (%) based on Airbnb rental potential
        // Formula:
        //  1 month collected revenue = Median price per night  30 nights  0.7 (70% occupancy)  0.85 (15% management fees)
        //  Short term revenue per sqft per month = 1 month collected revenue / Median Build up
        //  Short Term ROI = (Short term revenue per sqft per month  12 months) / median asking sales price psf  100%
        function calculateShortTermROI(adsEntry, centerLat, centerLon) {
            if (!adsEntry) return null;
            
            // Get median builtup area
            const builtupValues = adsEntry.builtupValues || [];
            if (builtupValues.length === 0) return null;
            const medianBuiltup = calculateMedian(builtupValues);
            if (!medianBuiltup || medianBuiltup <= 0) return null;
            
            // Get median asking sale price psf
            const salePsfValues = adsEntry.salePsfValues || [];
            if (salePsfValues.length === 0) return null;
            const medianSalePsf = calculateMedian(salePsfValues);
            if (!medianSalePsf || medianSalePsf <= 0) return null;
            
            // Get median Airbnb price per night within 300m
            const medianPricePerNight = getMedianAirbnbPricePerNight(centerLat, centerLon);
            if (!medianPricePerNight || medianPricePerNight <= 0) return null;
            
            // Calculate 1 month collected revenue
            // = Median price per night  30 nights  0.7 (70% occupancy)  0.85 (15% management fees)
            const oneMonthRevenue = medianPricePerNight * 30 * 0.7 * 0.85;
            
            // Short term revenue per sqft per month
            const revenuePerSqftPerMonth = oneMonthRevenue / medianBuiltup;
            
            // Short Term ROI = (Short term revenue per sqft per month  12 months) / median asking sales price psf  100%
            const shortTermROI = (revenuePerSqftPerMonth * 12 / medianSalePsf) * 100;
            
            return shortTermROI;
        }
        
        // Calculate average annual appreciation rate (%) based on year-on-year changes
        // Example:
        //  2022: 593, 2023: 532, 2024: 575, 2025: 652
        //  YoY %: (532-593)/593, (575-532)/532, (652-575)/575
        //  Average = mean of these YoY percentages
        function calculateAppreciationRate(chartData) {
            if (!chartData || chartData.length < 2) return null;
            
            const changes = [];
            for (let i = 1; i < chartData.length; i++) {
                const prev = chartData[i - 1];
                const curr = chartData[i];
                const prevPrice = prev && prev.medianPricePsf;
                const currPrice = curr && curr.medianPricePsf;
                
                if (typeof prevPrice === 'number' && typeof currPrice === 'number' &&
                    !isNaN(prevPrice) && !isNaN(currPrice) && prevPrice > 0) {
                    const pct = ((currPrice - prevPrice) / prevPrice) * 100;
                    changes.push(pct);
                }
            }
            
            if (!changes.length) return null;
            
            const sum = changes.reduce((acc, v) => acc + v, 0);
            return sum / changes.length;
        }
        
        function renderBarChart(data, options = {}) {
            if (data.length === 0) return;
            
            const metricKey = options.metricKey || 'medianPricePsf';
            const barsId    = options.barsId || 'chartBars';
            const yAxisId   = options.yAxisId || 'chartYAxis';
            const barClass  = options.barClass || '';
            
            const values = data
                .map(d => d[metricKey])
                .filter(v => typeof v === 'number' && !isNaN(v));
            if (!values.length) return;
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            
            // Compute a dynamic window around the data:
            // margin = (max - min) * 10% + 50
            const diff = maxValue - minValue;
            const margin = diff * 0.10 + 50;
            let lowBound = minValue - margin;
            if (lowBound < 0) lowBound = 0; // do not go below zero for axis label
            const highBound = maxValue + margin;
            const range = highBound - lowBound || 1; // avoid divide-by-zero
            
            const chartBars = document.getElementById(barsId);
            const chartYAxis = document.getElementById(yAxisId);
            
            if (!chartBars || !chartYAxis) {
                console.error('Chart elements not found');
                return;
            }
            
            // Clear previous content
            chartBars.innerHTML = '';
            chartYAxis.innerHTML = '';
            
            // Build Y-axis labels:
            //  - bottom: 0
            //  - next:   lowBound
            //  - then 3 evenly spaced between lowBound and highBound
            //  - top:    highBound
            const yLabels = [];
            const intermediateSteps = 3;
            yLabels.push(0);
            yLabels.push(lowBound);
            for (let i = 1; i <= intermediateSteps; i++) {
                const v = lowBound + (range * i / (intermediateSteps + 1));
                yLabels.push(v);
            }
            yLabels.push(highBound);
            
            // Render Y-axis labels from top to bottom
            yLabels
                .slice() // copy
                .sort((a, b) => b - a) // highest at top
                .forEach(v => {
                    const label = document.createElement('div');
                    label.textContent = `RM ${Math.round(v)}`;
                    chartYAxis.appendChild(label);
                });
            
            // Create bars scaled within [lowBound, highBound]
            data.forEach(item => {
                const barContainer = document.createElement('div');
                barContainer.className = 'chart-bar';
                
                const barWrapper = document.createElement('div');
                barWrapper.className = 'bar-container';
                barWrapper.style.height = '100%';
                
                // Map medianPricePsf into [0, 100]% of chart height based on [lowBound, highBound]
                const clamped = Math.max(lowBound, Math.min(highBound, item.medianPricePsf));
                const rawHeight = ((clamped - lowBound) / range) * 100;
                const barHeight = Math.max(10, rawHeight); // ensure a visible minimum
                
                const bar = document.createElement('div');
                bar.className = 'bar' + (barClass ? ` ${barClass}` : '');
                bar.style.height = `${barHeight}%`;
                
                const barValue = document.createElement('div');
                barValue.className = 'bar-value';
                barValue.textContent = `RM ${item[metricKey].toFixed(0)}`;
                
                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                barLabel.textContent = item.year;
                
                barWrapper.appendChild(bar);
                barWrapper.appendChild(barValue);
                barContainer.appendChild(barWrapper);
                barContainer.appendChild(barLabel);
                chartBars.appendChild(barContainer);
            });
        }

        // Extract numeric arrays from analysis table data
        // metric: 'psf' | 'price'
        function extractNumericArrayFromTable(tableData, metric) {
            const values = [];
            
            tableData.forEach(row => {
                let rawStr = null;
                
                if (metric === 'psf') {
                    rawStr = row.landAreaPsf;
                } else if (metric === 'price') {
                    rawStr = row.transactedPrice;
                }
                
                if (!rawStr) return;
                
                const numericStr = rawStr.toString().replace(/[^0-9.]/g, '');
                if (!numericStr) return;
                
                const num = parseFloat(numericStr);
                if (!isNaN(num) && num > 0) {
                    values.push(num);
                }
            });
            
            return values;
        }
        
        // Compute a box & whisker summary from numeric values
        function computeBoxPlotStats(values) {
            if (!values || !values.length) return null;
            
            const sorted = values.slice().sort((a, b) => a - b);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const median = computeQuantile(sorted, 0.5);
            const q1 = computeQuantile(sorted, 0.25);
            const q3 = computeQuantile(sorted, 0.75);
            const sum = sorted.reduce((acc, v) => acc + v, 0);
            const mean = sum / sorted.length;
            
            return { min, q1, median, q3, max, mean };
        }
        
        function computeQuantile(sortedValues, q) {
            if (!sortedValues.length) return null;
            if (sortedValues.length === 1) return sortedValues[0];
            
            const pos = (sortedValues.length - 1) * q;
            const base = Math.floor(pos);
            const rest = pos - base;
            
            if (sortedValues[base + 1] !== undefined) {
                return sortedValues[base] + rest * (sortedValues[base + 1] - sortedValues[base]);
            }
            
            return sortedValues[base];
        }
        
        // Render a horizontal box & whisker plot into the given container IDs
        // options:
        //  - plotId: main plot container
        //  - xAxisQ1Q3Id: row 1 (Q1 & Q3)
        //  - xAxisMeanId: row 2 (Mean)
        //  - xAxisMedianId: row 3 (Median)
        //  - xAxisMinMaxId: row 4 (Min & Max)
        //  - labelPrefix: base for element IDs (optional)
        //  - isPricePsf: true for psf, false for price
        function renderBoxPlot(values, options = {}) {
            if (!values || !values.length) return;
            
            const plotId         = options.plotId || 'boxPlot';
            const xAxisQ1Q3Id    = options.xAxisQ1Q3Id || null;
            const xAxisMeanId    = options.xAxisMeanId || null;
            const xAxisMedianId  = options.xAxisMedianId || null;
            const xAxisMinMaxId  = options.xAxisMinMaxId || null;
            const labelPrefix    = options.labelPrefix || '';
            const isPricePsf     = options.isPricePsf || false;
            
            const plotEl        = document.getElementById(plotId);
            const axisQ1Q3El    = xAxisQ1Q3Id ? document.getElementById(xAxisQ1Q3Id) : null;
            const axisMeanEl    = xAxisMeanId ? document.getElementById(xAxisMeanId) : null;
            const axisMedianEl  = xAxisMedianId ? document.getElementById(xAxisMedianId) : null;
            const axisMinMaxEl  = xAxisMinMaxId ? document.getElementById(xAxisMinMaxId) : null;
            
            if (!plotEl) {
                console.error('Box plot elements not found');
                return;
            }
            
            plotEl.innerHTML = '';
            if (axisQ1Q3El) axisQ1Q3El.innerHTML = '';
            if (axisMeanEl) axisMeanEl.innerHTML = '';
            if (axisMedianEl) axisMedianEl.innerHTML = '';
            if (axisMinMaxEl) axisMinMaxEl.innerHTML = '';
            
            const stats = computeBoxPlotStats(values);
            if (!stats) return;
            
            const { min, q1, median, q3, max, mean } = stats;
            const range = max - min || 1;
            const toPct = (v) => ((v - min) / range) * 100;
            
            // Central line (min to max)
            const line = document.createElement('div');
            line.className = 'boxplot-line';
            plotEl.appendChild(line);
            
            // Whiskers at min and max
            const whiskerMin = document.createElement('div');
            whiskerMin.className = 'boxplot-whisker';
            whiskerMin.style.left = `${toPct(min)}%`;
            plotEl.appendChild(whiskerMin);
            
            const whiskerMax = document.createElement('div');
            whiskerMax.className = 'boxplot-whisker';
            whiskerMax.style.left = `${toPct(max)}%`;
            plotEl.appendChild(whiskerMax);
            
            // Box from Q1 to Q3
            const box = document.createElement('div');
            box.className = 'boxplot-box';
            const leftQ1 = toPct(q1);
            const rightQ3 = toPct(q3);
            box.style.left = `${leftQ1}%`;
            box.style.width = `${Math.max(3, rightQ3 - leftQ1)}%`;
            plotEl.appendChild(box);
            
            // Median line
            const medianLine = document.createElement('div');
            medianLine.className = 'boxplot-median';
            medianLine.style.left = `${toPct(median)}%`;
            plotEl.appendChild(medianLine);

            // Mean black dot
            const meanDot = document.createElement('div');
            meanDot.className = 'boxplot-mean-dot';
            meanDot.style.left = `${toPct(mean)}%`;
            plotEl.appendChild(meanDot);

            // X-axis labels:
            // Row 1: Q1 (left-aligned) and Q3 (right-aligned)
            if (axisQ1Q3El) {
                const q1Label = document.createElement('div');
                const q3Label = document.createElement('div');
                
                const formatVal = (v) => isPricePsf ? `RM ${Math.round(v)}` : `RM ${formatLargeNumber(v)}`;
                
                q1Label.textContent = `Q1: ${formatVal(q1)}`;
                if (labelPrefix) q1Label.id = `${labelPrefix}-q1-label`;
                q1Label.style.position = 'absolute';
                q1Label.style.left = `${toPct(q1)}%`;
                q1Label.style.transform = 'translateX(-100%)'; // align right
                q1Label.style.whiteSpace = 'nowrap';
                
                q3Label.textContent = `Q3: ${formatVal(q3)}`;
                if (labelPrefix) q3Label.id = `${labelPrefix}-q3-label`;
                q3Label.style.position = 'absolute';
                q3Label.style.left = `${toPct(q3)}%`;
                q3Label.style.transform = 'translateX(0)'; // align right
                q3Label.style.whiteSpace = 'nowrap';
                
                axisQ1Q3El.appendChild(q1Label);
                axisQ1Q3El.appendChild(q3Label);
            }
            
            // Row 2: Mean (center)
            if (axisMeanEl) {
                const meanLabel = document.createElement('div');
                const text = isPricePsf ? `Mean: RM ${Math.round(mean)}` : `Mean: RM ${formatLargeNumber(mean)}`;
                meanLabel.textContent = text;
                if (labelPrefix) meanLabel.id = `${labelPrefix}-mean-label`;
                meanLabel.style.position = 'absolute';
                meanLabel.style.left = `${toPct(mean)}%`;
                meanLabel.style.transform = 'translateX(-50%)';
                meanLabel.style.whiteSpace = 'nowrap';
                axisMeanEl.appendChild(meanLabel);
            }
            
            // Row 3: Median (center)
            if (axisMedianEl) {
                const medianLabel = document.createElement('div');
                const txt = isPricePsf ? `Median: RM ${Math.round(median)}` : `Median: RM ${formatLargeNumber(median)}`;
                medianLabel.textContent = txt;
                if (labelPrefix) medianLabel.id = `${labelPrefix}-median-label`;
                medianLabel.style.position = 'absolute';
                medianLabel.style.left = `${toPct(median)}%`;
                medianLabel.style.transform = 'translateX(-50%)';
                medianLabel.style.whiteSpace = 'nowrap';
                axisMedianEl.appendChild(medianLabel);
            }
            
            // Row 4: Min (right-aligned) and Max (left-aligned)
            if (axisMinMaxEl) {
                const makeLabel = (val, prefix, align, idSuffix) => {
                    const label = document.createElement('div');
                    const txt = isPricePsf ? `${prefix}: RM ${Math.round(val)}` : `${prefix}: RM ${formatLargeNumber(val)}`;
                    label.textContent = txt;
                    if (labelPrefix && idSuffix) {
                        label.id = `${labelPrefix}-${idSuffix}`;
                    }
                    label.style.position = 'absolute';
                    label.style.left = `${toPct(val)}%`;
                    if (align === 'left') {
                        label.style.transform = 'translateX(-100%)';
                    } else if (align === 'right') {
                        label.style.transform = 'translateX(0)';
                    } else {
                        label.style.transform = 'translateX(-50%)';
                    }
                    label.style.whiteSpace = 'nowrap';
                    return label;
                };
                
                axisMinMaxEl.appendChild(makeLabel(min, 'Min', 'right', 'min-label'));
                axisMinMaxEl.appendChild(makeLabel(max, 'Max', 'left', 'max-label'));
            }
        }
        
        // Build histogram data from numeric values
        function buildHistogram(values, binCount = 8) {
            if (!values || !values.length) return [];
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            if (min === max) {
                return [{
                    from: min,
                    to: max,
                    count: values.length
                }];
            }
            
            const range = max - min;
            const binSize = range / binCount;
            const bins = [];
            
            for (let i = 0; i < binCount; i++) {
                const from = min + i * binSize;
                const to = i === binCount - 1 ? max : min + (i + 1) * binSize;
                bins.push({ from, to, count: 0 });
            }
            
            values.forEach(v => {
                let idx = Math.floor((v - min) / binSize);
                if (idx < 0) idx = 0;
                if (idx >= binCount) idx = binCount - 1;
                bins[idx].count += 1;
            });
            
            return bins;
        }
        
        function formatLargeNumber(value) {
            if (value >= 1000000) {
                return (value / 1000000).toFixed(1) + 'M';
            }
            if (value >= 1000) {
                return (value / 1000).toFixed(0) + 'k';
            }
            return Math.round(value).toString();
        }
        
        // Render histogram for prices
        // options:
        //  - barsId, yAxisId: target elements
        //  - isPsf: true when values are price per square foot (no k/M formatting, show 2 decimals)
        function renderPriceHistogram(bins, options = {}) {
            if (!bins || !bins.length) return;
            
            const barsId = options.barsId || 'histPriceBars';
            const yAxisId = options.yAxisId || 'histPriceYAxis';
            const isPsf  = options.isPsf || false;
            
            const barsEl = document.getElementById(barsId);
            const yAxisEl = document.getElementById(yAxisId);
            
            if (!barsEl || !yAxisEl) {
                console.error('Histogram elements not found');
                return;
            }
            
            barsEl.innerHTML = '';
            yAxisEl.innerHTML = '';
            
            const counts = bins.map(b => b.count);
            const maxCount = Math.max(...counts) || 1;
            
            // Y-axis labels: 0, mid, max
            const yLabels = [0, Math.round(maxCount / 2), maxCount];
            yLabels
                .slice()
                .sort((a, b) => b - a)
                .forEach(v => {
                    const label = document.createElement('div');
                    label.textContent = v.toString();
                    yAxisEl.appendChild(label);
                });
            
            bins.forEach(bin => {
                const barContainer = document.createElement('div');
                barContainer.className = 'histogram-bar';
                
                const bar = document.createElement('div');
                const height = maxCount === 0 ? 0 : (bin.count / maxCount) * 100;
                bar.className = 'histogram-bin';
                bar.style.height = `${height}%`;
                
                const countLabel = document.createElement('div');
                countLabel.className = 'histogram-count-label';
                countLabel.textContent = bin.count.toString();
                
                const rangeLabel = document.createElement('div');
                rangeLabel.className = 'bar-label';
                let fromVal;
                let toVal;
                if (isPsf) {
                    fromVal = bin.from.toFixed(2);
                    toVal   = bin.to.toFixed(2);
                } else {
                    fromVal = formatLargeNumber(bin.from);
                    toVal   = formatLargeNumber(bin.to);
                }
                rangeLabel.textContent = `RM ${fromVal}-${toVal}`;
                
                barContainer.appendChild(bar);
                barContainer.appendChild(countLabel);
                barContainer.appendChild(rangeLabel);
                barsEl.appendChild(barContainer);
            });
        }
        
        // Questionnaire Data
        const questionnaireData = {
            purpose: '',
            locations: [], // Array of { id, name, lat, lng, locationType }
            budget: '',
            minBudget: null,
            maxBudget: null,
            propertySize: {
                min: null,
                max: null,
                unit: 'sqft'
            },
            fullData: null // Complete JSON data from questionnaire
        };

        // Step Management
        let currentStep = 1;
        let guideStep = 0; // For step-by-step guide in step 2
        const GUIDE_STORAGE_KEY = 'propertyzap_map_guide_seen';
        const hasSeenGuide = localStorage.getItem(GUIDE_STORAGE_KEY) === 'true';

        function selectOption(button, field) {
            // Remove selected class from all options in the same group
            const options = button.parentElement.querySelectorAll('.option-btn');
            options.forEach(opt => opt.classList.remove('selected'));
            
            // Add selected class to clicked option
            button.classList.add('selected');
            
            // Store the value
            questionnaireData[field] = button.dataset.value;
            
            // Enable next button for step 1
            if (field === 'purpose') {
                document.getElementById('nextBtn1').disabled = false;
            }

            updateGuideSteps();
        }

        function nextStep(step) {
            // Validate current step
            if (currentStep === 1) {
                if (!questionnaireData.purpose) {
                    alert('Please select an option');
                    return;
                }
                
                // If not "own-stay", show coming soon message
                if (questionnaireData.purpose !== 'own-stay') {
                    // For now, just show a simple coming soon alert and keep user on Step 1
                    alert('Questionnaire for this option is coming soon. Please choose "Own Stay" to continue.');
                    return;
                }
                
                // Hide Step 1 overlay and move to Step 2 (map + guide only)
                document.getElementById('step1Overlay').classList.add('hidden');
                
                // In tutorial mode, don't hide the overlay - it will transition to Step 2 spotlight
                // In normal mode, hide it if it was showing
                if (tutorialMode) {
                    // Don't hide - let startStep2Guide() handle the transition
                } else {
                    hideTutorialOverlay();
                }
            }
            
            if (currentStep === 2) {
                const firstLocation = getFirstLocation();
                if (!firstLocation) {
                    alert('Please pin at least one location on the map');
                    return;
                }
            }

            // Show/hide map search control and guide based on step
            if (step === 2) {
                currentStep = step;
                const searchControl = document.getElementById('mapSearchControl');
                searchControl.classList.remove('hidden');
                map.invalidateSize();
                // Skip guide overlay if user already has pinned locations
                const hasPinnedLocations = questionnaireData.locations && questionnaireData.locations.length > 0;
                // In tutorial mode always show guide; in normal mode show it only once
                // But skip if locations already exist
                if (!hasPinnedLocations && (tutorialMode || !hasSeenGuide)) {
                    // Small delay to ensure Step 1 overlay is hidden before showing Step 2 spotlight
                    setTimeout(() => {
                        startStep2Guide();
                    }, 50);
                }
            } else {
                currentStep = step;
                const searchControl = document.getElementById('mapSearchControl');
                searchControl.classList.add('hidden');
                searchControl.classList.remove('collapsed');
                document.body.classList.remove('search-collapsed');
                document.getElementById('guideOverlay').classList.add('hidden');
                guideStep = 0;
            }

            updateGuideSteps();
        }

        function previousStep(step) {
            // Hide map search control when going back from step 2
            if (step !== 2) {
                const searchControl = document.getElementById('mapSearchControl');
                searchControl.classList.add('hidden');
                searchControl.classList.remove('collapsed');
                document.body.classList.remove('search-collapsed');
                document.getElementById('guideOverlay').classList.add('hidden');
                guideStep = 0;
            }
        }

        function goBackToStep1() {
            // Reset Step 2 data
            // Clear all location markers
            locationMarkers.forEach((marker) => {
                map.removeLayer(marker);
            });
            locationMarkers.clear();
            if (previewMarker) {
                map.removeLayer(previewMarker);
                previewMarker = null;
            }
            // Clear all locations
            locationMarkers.forEach((marker) => {
                map.removeLayer(marker);
            });
            locationMarkers.clear();
            questionnaireData.locations = [];
            
            // Remove work-location-set and budget-set classes to disable interactions
            document.body.classList.remove('work-location-set');
            document.body.classList.remove('budget-set');
            const workLocationInput = document.getElementById('workLocation');
            if (workLocationInput) {
                workLocationInput.value = '';
            }
            document.getElementById('locationSearch').value = '';
            const nextBtn2 = document.getElementById('nextBtn2');
            if (nextBtn2) {
                nextBtn2.disabled = true;
            }
            
            // Reset purpose selection
            questionnaireData.purpose = '';
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.getElementById('nextBtn1').disabled = true;
            
            // Show Step 1 overlay
            document.getElementById('step1Overlay').classList.remove('hidden');
            document.getElementById('mapSearchControl').classList.add('hidden');
            document.getElementById('guideOverlay').classList.add('hidden');
            
            currentStep = 1;
            guideStep = 0;

            // Show tutorial overlay for Step 1 if tutorial mode is ON
            // Skip tutorial if user already has pinned locations
            const hasPinnedLocations = questionnaireData.locations && questionnaireData.locations.length > 0;
            if (tutorialMode && !hasPinnedLocations) {
                setTimeout(() => {
                    showTutorialOverlayStep1();
                }, 100);
            }

            updateGuideSteps();
        }

        function showStepContent(contentId) {
            // Hide all step contents
            document.querySelectorAll('.step-content').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Show selected step content
            document.getElementById(contentId).classList.remove('hidden');
        }

        // Tutorial mode toggle (on = guided flow, off = normal mode)
        let tutorialMode = localStorage.getItem('propertyzap_tutorial_mode') === 'on';

        // Expose toggle in header
        function loadUserProfileInfo() {
            try {
                // Load user name
                const storedName = localStorage.getItem('propertyzap_user_name');
                const userNameEl = document.getElementById('userProfileName');
                if (userNameEl) {
                    userNameEl.textContent = storedName || 'User';
                }

                // Load user email (optional - can be displayed in dropdown if needed)
                const storedEmail = localStorage.getItem('propertyzap_user_email');
                // Email can be used for future features if needed
            } catch (e) {
                console.warn('Unable to load user profile info:', e);
            }
        }

        function initUserProfile() {
            // Load user profile information
            loadUserProfileInfo();

            // User Profile Menu Toggle
            const userProfileMenuBtn = document.getElementById('userProfileMenuBtn');
            const userProfileMenu = document.getElementById('userProfileMenu');
            const userProfileDropdown = document.getElementById('userProfileDropdown');
            
            if (userProfileMenuBtn && userProfileMenu) {
                // Function to toggle dropdown
                const toggleDropdown = function(e) {
                    e.stopPropagation();
                    userProfileMenu.classList.toggle('active');
                };
                
                // Add click handler to arrow button
                userProfileMenuBtn.addEventListener('click', toggleDropdown);
                
                // Add click handler to avatar
                const userProfileAvatar = document.getElementById('userProfileAvatar');
                if (userProfileAvatar) {
                    userProfileAvatar.addEventListener('click', toggleDropdown);
                }
                
                // Add click handler to username
                const userProfileName = document.getElementById('userProfileName');
                if (userProfileName) {
                    userProfileName.addEventListener('click', toggleDropdown);
                }
                
                // Also add click handler to the name row container
                const userProfileNameRow = userProfileName ? userProfileName.closest('.user-profile-name-row') : null;
                if (userProfileNameRow) {
                    userProfileNameRow.addEventListener('click', toggleDropdown);
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', function(e) {
                    if (!userProfileMenu.contains(e.target) && 
                        !userProfileAvatar?.contains(e.target) && 
                        !userProfileNameRow?.contains(e.target)) {
                        userProfileMenu.classList.remove('active');
                    }
                });
                
                // Handle logout
                const logoutBtn = document.getElementById('userProfileLogout');
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (confirm('Are you sure you want to logout?')) {
                            // Clear basic session info
                            localStorage.removeItem('propertyzap_user_name');
                            localStorage.removeItem('propertyzap_user_role');
                            localStorage.removeItem('propertyzap_username');
                            localStorage.removeItem('propertyzap_signed_up');
                            // Redirect to sign-in page
                            window.location.href = 'sign-in.html';
                        }
                    });
                }
                
                // Handle settings
                const settingsBtn = document.getElementById('userProfileSettings');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        // TODO: Implement settings functionality
                        alert('Settings coming soon!');
                    });
                }
                
                // Load user data if available (reuse userProfileName from above)
                const storedUser = localStorage.getItem('propertyzap_user');
                if (storedUser && userProfileName) {
                    try {
                        const userData = JSON.parse(storedUser);
                        if (userData.name || userData.email) {
                            userProfileName.textContent = userData.name || userData.email.split('@')[0] || 'User';
                        }
                    } catch (e) {
                        console.error('Error parsing user data:', e);
                    }
                }
            }
        }

        function initTutorialToggle() {
            const toggle = document.getElementById('tutorialToggle');
            if (!toggle) return;
            toggle.checked = tutorialMode;
            toggle.addEventListener('change', function () {
                tutorialMode = this.checked;
                localStorage.setItem('propertyzap_tutorial_mode', tutorialMode ? 'on' : 'off');

                // When turning tutorial mode on, restart flow at step 1 for a clean guided experience
                if (tutorialMode) {
                    // allow guidance to show again in tutorial mode
                    guideStep = 0;
                    guideStep = 0;
                    // show the step 1 overlay again
                    const overlay = document.getElementById('step1Overlay');
                    if (overlay) overlay.classList.remove('hidden');
                    currentStep = 1;
                    const mapSearch = document.getElementById('mapSearchControl');
                    if (mapSearch) mapSearch.classList.add('hidden');
                    const guide = document.getElementById('guideOverlay');
                    if (guide) guide.classList.add('hidden');
                    // Hide tutorial overlay if active
                    hideTutorialOverlay();
                    // Show tutorial overlay for Step 1
                    setTimeout(() => {
                        showTutorialOverlayStep1();
                    }, 100);
                } else {
                    // When turning tutorial mode off, hide tutorial overlay
                    hideTutorialOverlay();
                }
            });
        }

        // No-op guide step updater (left sidebar steps removed, kept for compatibility)
        function updateGuideSteps() {}

        // Step 2 Guide Functions - New Tutorial System
        function startStep2Guide() {
            // Only show tutorial overlay if tutorial mode is ON
            if (!tutorialMode) {
                // Normal mode: use old guide system (show once)
                if (!hasSeenGuide) {
                    guideStep = 1;
                    highlightSearchBar();
                    showGuide('', 'Step 2: Search for Location', 'Type your work location in the search bar highlighted at the top of the map. Click "Got it!" to start typing.', () => {});
                }
                return;
            }

            // Tutorial mode: Show full-screen overlay with spotlight
            showTutorialOverlay();
        }

        function showTutorialOverlay() {
            const overlay = document.getElementById('tutorialOverlay');
            const spotlight = document.getElementById('tutorialSpotlight');
            const tooltip = document.getElementById('tutorialTooltip');
            const searchControl = document.getElementById('mapSearchControl');
            const searchInput = document.getElementById('locationSearch');

            if (!overlay || !searchControl) return;

            // Clean up Step 1 highlight styles if they exist
            const questionOptions = document.querySelector('.question-options');
            if (questionOptions) {
                questionOptions.style.border = '';
                questionOptions.style.borderRadius = '';
                questionOptions.style.padding = '';
                questionOptions.style.background = '';
                questionOptions.style.boxShadow = '';
            }

            // Function to update positions
            const updatePositions = () => {
                // Get search bar position
                const rect = searchControl.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate spotlight position (center on search bar)
                const spotlightSize = 280; // Size of the spotlight circle
                const spotlightX = centerX;
                const spotlightY = centerY;

                // Update spotlight mask to center on search bar
                spotlight.style.maskImage = `radial-gradient(circle ${spotlightSize}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 60}px)`;
                spotlight.style.webkitMaskImage = `radial-gradient(circle ${spotlightSize}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 60}px)`;

                // Position tooltip above search bar with some spacing
                tooltip.style.left = `${centerX}px`;
                tooltip.style.top = `${Math.max(20, rect.top - 80)}px`;
                tooltip.style.transform = 'translate(-50%, 0)';
                tooltip.className = 'tutorial-tooltip arrow-down';
                tooltip.querySelector('.tutorial-tooltip-text').textContent = 'Type your work location here and click search.';
            };

            // Initial position update
            updatePositions();

            // Show overlay (or update if already visible from Step 1)
            if (overlay.classList.contains('hidden')) {
                // Overlay is hidden, show it fresh
                overlay.classList.remove('hidden');
                setTimeout(() => {
                    overlay.classList.add('active');
                    // Recalculate positions after overlay is shown (in case of layout shifts)
                    updatePositions();
                }, 10);
            } else {
                // Overlay is already visible (transitioning from Step 1), just update positions immediately
                overlay.classList.add('active');
                // Small delay to ensure Step 1 overlay is hidden and search bar is visible
                setTimeout(() => {
                    updatePositions();
                }, 50);
            }

            // Update positions on window resize
            // Remove old handler if exists
            if (overlay._resizeHandler) {
                window.removeEventListener('resize', overlay._resizeHandler);
            }
            const resizeHandler = () => {
                if (overlay.classList.contains('active')) {
                    updatePositions();
                }
            };
            window.addEventListener('resize', resizeHandler);
            overlay._resizeHandler = resizeHandler; // Store handler reference for cleanup

            // Lock all UI except search bar
            document.body.classList.add('tutorial-locked');

            // Highlight search bar
            searchControl.classList.add('highlight');
            searchInput.classList.add('highlight');
            searchInput.focus();
        }

        function showTutorialOverlayStep1() {
            const overlay = document.getElementById('tutorialOverlay');
            const spotlight = document.getElementById('tutorialSpotlight');
            const tooltip = document.getElementById('tutorialTooltip');
            const questionOptions = document.querySelector('.question-options');

            if (!overlay || !questionOptions) return;

            // Function to update positions
            const updatePositions = () => {
                // Get question-options position
                const rect = questionOptions.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate spotlight position (center on question-options)
                // Make spotlight large enough to cover all three buttons
                const spotlightSize = Math.max(300, rect.height / 2 + 50);
                const spotlightX = centerX;
                const spotlightY = centerY;

                // Update spotlight mask to center on question-options
                spotlight.style.maskImage = `radial-gradient(ellipse ${spotlightSize}px ${spotlightSize * 0.8}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 80}px)`;
                spotlight.style.webkitMaskImage = `radial-gradient(ellipse ${spotlightSize}px ${spotlightSize * 0.8}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 80}px)`;

                // Position tooltip above question-options with some spacing
                tooltip.style.left = `${centerX}px`;
                tooltip.style.top = `${Math.max(20, rect.top - 100)}px`;
                tooltip.style.transform = 'translate(-50%, 0)';
                tooltip.className = 'tutorial-tooltip arrow-down';
                tooltip.querySelector('.tutorial-tooltip-text').textContent = 'Select your property purpose to get started.';
            };

            // Initial position update
            updatePositions();

            // Show overlay
            overlay.classList.remove('hidden');
            setTimeout(() => {
                overlay.classList.add('active');
                // Recalculate positions after overlay is shown (in case of layout shifts)
                updatePositions();
            }, 10);

            // Update positions on window resize
            const resizeHandler = () => {
                if (overlay.classList.contains('active')) {
                    updatePositions();
                }
            };
            window.addEventListener('resize', resizeHandler);
            overlay._resizeHandler = resizeHandler; // Store handler reference for cleanup

            // Lock all UI except Step 1 overlay content
            document.body.classList.add('tutorial-locked');

            // Highlight question-options area
            questionOptions.style.border = '3px solid var(--primary-color)';
            questionOptions.style.borderRadius = '12px';
            questionOptions.style.padding = '0.5rem';
            questionOptions.style.background = 'rgba(37, 99, 235, 0.05)';
            questionOptions.style.boxShadow = '0 0 0 4px rgba(37, 99, 235, 0.1)';
        }

        function hideTutorialOverlay() {
            const overlay = document.getElementById('tutorialOverlay');
            const searchControl = document.getElementById('mapSearchControl');
            const searchInput = document.getElementById('locationSearch');

            if (!overlay) return;

            // Remove resize handler if it exists
            if (overlay._resizeHandler) {
                window.removeEventListener('resize', overlay._resizeHandler);
                delete overlay._resizeHandler;
            }

            // Fade out overlay
            overlay.classList.remove('active');
            setTimeout(() => {
                overlay.classList.add('hidden');
            }, 400);

            // Unlock UI
            document.body.classList.remove('tutorial-locked');

            // Remove highlights
            if (searchControl) searchControl.classList.remove('highlight');
            if (searchInput) searchInput.classList.remove('highlight');
            
            // Remove question-options highlight if exists
            const questionOptions = document.querySelector('.question-options');
            if (questionOptions) {
                questionOptions.style.border = '';
                questionOptions.style.borderRadius = '';
                questionOptions.style.padding = '';
                questionOptions.style.background = '';
                questionOptions.style.boxShadow = '';
            }
            
            // Remove budget section highlight if exists
            const budgetSection = document.querySelector('.locations-budget');
            if (budgetSection) {
                budgetSection.style.border = '';
                budgetSection.style.borderRadius = '';
                budgetSection.style.padding = '';
                budgetSection.style.background = '';
                budgetSection.style.boxShadow = '';
            }
            
            // Remove Start Analysis button highlight if exists
            const startAnalysisBtn = document.querySelector('.start-analysis-btn');
            if (startAnalysisBtn) {
                startAnalysisBtn.style.border = '';
                startAnalysisBtn.style.boxShadow = '';
                startAnalysisBtn.style.animation = '';
            }
        }

        function highlightSearchBar() {
            const searchControl = document.getElementById('mapSearchControl');
            const searchInput = document.getElementById('locationSearch');
            
            searchControl.classList.add('highlight');
            searchInput.classList.add('highlight');
            searchInput.focus();
            
            // Update guide text
            const guideEl = document.getElementById('currentGuide');
            if (guideEl) {
                guideEl.textContent = '1. Type your work address in the search box (highlighted)';
            }
        }

        function showGuide(icon, title, text, onClose) {
            if (hasSeenGuide) return;
            document.getElementById('guideIcon').textContent = icon;
            document.getElementById('guideTitle').textContent = title;
            document.getElementById('guideText').textContent = text;
            document.getElementById('guideOverlay').classList.remove('hidden');
        }

        function closeGuide() {
            document.getElementById('guideOverlay').classList.add('hidden');
            
            // Mark guide as seen so we don't show it again for this user
            try {
                localStorage.setItem(GUIDE_STORAGE_KEY, 'true');
            } catch (e) {
                // ignore storage errors (e.g. private mode)
            }

            // Allow typing/search after user acknowledges the guide
            guideStep = 0;
        }

        // --- Search & Suggestions ---
        let searchTimeout;
        let currentSuggestions = [];

        // Handle typing for suggestions (debounced)
        document.getElementById('locationSearch').addEventListener('input', function (e) {
            // In tutorial mode, allow typing freely
            // In normal mode, while step 2 guide is active, require the user to click "Got it!" first
            if (!tutorialMode && guideStep === 1) {
                e.target.blur();
                return;
            }

            const query = e.target.value.trim();
            clearTimeout(searchTimeout);

            if (query.length < 3) {
                document.getElementById('searchSuggestions').classList.remove('show');
                return;
            }

            searchTimeout = setTimeout(() => {
                searchAutocomplete(query);
            }, 300);
        });

        // Close suggestions when clicking outside
        document.addEventListener('click', function (e) {
            const searchControl = document.getElementById('mapSearchControl');
            if (!searchControl.contains(e.target)) {
                document.getElementById('searchSuggestions').classList.remove('show');
            }
        });

        async function searchAutocomplete(query) {
            try {
                // Don't append ", Malaysia" if query already contains location indicators
                // This allows for more flexible searches
                let searchQuery = query;
                if (!query.toLowerCase().includes('malaysia') && !query.toLowerCase().includes('kl') && !query.toLowerCase().includes('kuala lumpur')) {
                    searchQuery = query + ', Malaysia';
                }
                
                // Get current map bounds to prioritize results within view
                const bounds = map.getBounds();
                const viewbox = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
                
                // Enhanced Nominatim query with better parameters
                const url = `https://nominatim.openstreetmap.org/search?` +
                    `format=json&` +
                    `q=${encodeURIComponent(searchQuery)}&` +
                    `limit=8&` +
                    `countrycodes=my&` +
                    `addressdetails=1&` +
                    `extratags=1&` +
                    `namedetails=1&` +
                    `viewbox=${encodeURIComponent(viewbox)}&` +
                    `bounded=0&` +
                    `dedupe=1`;
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'PropertyZap/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Search service unavailable');
                }
                
                const data = await response.json();
                
                // Sort results by relevance (prioritize exact matches and important places)
                const sortedData = (data || []).sort((a, b) => {
                    // Prioritize results with higher importance (lower number = more important)
                    const importanceA = parseFloat(a.importance || 1);
                    const importanceB = parseFloat(b.importance || 1);
                    
                    // Check if query matches the name more closely
                    const queryLower = query.toLowerCase();
                    const nameA = (a.display_name || '').toLowerCase();
                    const nameB = (b.display_name || '').toLowerCase();
                    
                    const startsWithA = nameA.startsWith(queryLower);
                    const startsWithB = nameB.startsWith(queryLower);
                    
                    if (startsWithA && !startsWithB) return -1;
                    if (!startsWithA && startsWithB) return 1;
                    
                    return importanceA - importanceB;
                });
                
                currentSuggestions = sortedData.slice(0, 8); // Limit to top 8
                displaySuggestions(currentSuggestions);
            } catch (error) {
                console.error('Autocomplete error:', error);
                // Show error message to user
                const container = document.getElementById('searchSuggestions');
                container.innerHTML = '<div class="suggestion-item" style="color: #ef4444;">Unable to load suggestions. Please try again.</div>';
                container.classList.add('show');
            }
        }

        function displaySuggestions(suggestions) {
            const container = document.getElementById('searchSuggestions');
            container.innerHTML = '';

            if (!suggestions.length) {
                container.classList.remove('show');
                return;
            }

            suggestions.forEach((sugg) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                
                // Extract name and address more intelligently
                const displayName = sugg.display_name || '';
                const parts = displayName.split(',');
                
                // Get the primary name (first part, usually the place name)
                const name = parts[0].trim();
                
                // Build a cleaner address (skip the name part, show location hierarchy)
                // Usually: name, area, city, state, country
                let address = '';
                if (parts.length > 1) {
                    // Show area, city, state if available
                    const addressParts = parts.slice(1, Math.min(4, parts.length));
                    address = addressParts.map(p => p.trim()).join(', ');
                } else {
                    address = displayName;
                }
                
                // Add type/class indicator if available
                const type = sugg.type || sugg.class || '';
                const typeLabel = type ? ` (${type})` : '';
                
                item.innerHTML = `
                    <div class="suggestion-name">${name}${typeLabel}</div>
                    <div class="suggestion-address">${address}</div>
                `;
                item.addEventListener('click', () => {
                    selectSuggestion(sugg);
                });
                container.appendChild(item);
            });

            container.classList.add('show');
        }

        function selectSuggestion(suggestion) {
            const searchInput = document.getElementById('locationSearch');
            const suggestionsContainer = document.getElementById('searchSuggestions');

            const name = suggestion.display_name.split(',')[0];
            const lat = parseFloat(suggestion.lat);
            const lon = parseFloat(suggestion.lon);

            searchInput.value = name;
            suggestionsContainer.classList.remove('show');

            // Don't hide overlay - it will transition to location popup spotlight
            // Remove highlight from search bar
            document.getElementById('mapSearchControl').classList.remove('highlight');
            searchInput.classList.remove('highlight');

            // Move map to location (more zoomed in)
            map.setView([lat, lon], 18.5);
            
            // Remove existing preview marker if any (keep work location marker)
            if (previewMarker) {
                map.removeLayer(previewMarker);
                previewMarker = null;
            }
            
            // Create temporary preview marker (keep existing work location marker visible)
            previewMarker = L.marker([lat, lon], { draggable: false }).addTo(map);
            
            // Store pending location for confirmation
            pendingClickLocation = { lat, lon, name: name };
            
            // Show location popup with confirmation
            showLocationPopup(lat, lon, name);
            
            // Show popup on preview marker
            const latText = lat.toFixed(4);
            const lngText = lon.toFixed(4);
            const html = `<strong>Selected Location</strong><br>${name}<br><small>Lat: ${latText}, Lng: ${lngText}</small><br><em>Select location type and confirm.</em>`;
            previewMarker.bindPopup(html).openPopup();
        }

        // Search location using Nominatim (Search button)
        async function searchLocation() {
            const searchInput = document.getElementById('locationSearch');
            const query = searchInput.value.trim();
            
            if (!query) {
                alert('Please enter a location to search');
                return;
            }
            
            // Remove highlight (but don't hide overlay - it will transition to location popup spotlight)
            document.getElementById('mapSearchControl').classList.remove('highlight');
            searchInput.classList.remove('highlight');
            
            try {
                const searchQuery = query + ', Malaysia';
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&limit=1&countrycodes=my`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lon = parseFloat(result.lon);
                    const name = result.display_name.split(',')[0];
                    
                    // Move map to location (more zoomed in)
                    map.setView([lat, lon], 17);
                    
                    // Remove existing preview marker if any (keep work location marker)
                    if (previewMarker) {
                        map.removeLayer(previewMarker);
                        previewMarker = null;
                    }
                    
                    // Create temporary preview marker (keep existing work location marker visible)
                    previewMarker = L.marker([lat, lon], { draggable: false }).addTo(map);
                    
                    // Store pending location for confirmation
                    pendingClickLocation = { lat, lon, name: name };
                    
                    // Show location popup with confirmation
                    showLocationPopup(lat, lon, name);
                    
                    // Show popup on preview marker
                    const latText = lat.toFixed(4);
                    const lngText = lon.toFixed(4);
                    const html = `<strong>Selected Location</strong><br>${name}<br><small>Lat: ${latText}, Lng: ${lngText}</small><br><em>Click "Set as Work Location" to confirm.</em>`;
                    previewMarker.bindPopup(html).openPopup();
                    
                } else {
                    alert('Location not found. Please try a different search term or click on the map directly.');
                }
            } catch (error) {
                console.error('Search error:', error);
                alert('Search failed. Please try clicking on the map directly.');
            }
        }

        // Click on map to preview location with a pin, then confirm as work location
        map.on('click', function(e) {
            // Clear routes when clicking on map background (not on markers or popups)
            // Check if click target is the map container itself
            const target = e.originalEvent.target;
            if (target && (target.classList.contains('leaflet-container') || 
                (target.classList.contains('leaflet-pane') && !target.closest('.leaflet-marker-icon')))) {
                // Only clear if not clicking on a marker
                if (!target.closest('.leaflet-marker-icon') && !target.closest('.leaflet-popup')) {
                    clearRoutes();
                    currentCondoMarker = null;
                }
            }
            // Only allow clicking if we're on step 2
            if (currentStep === 2) {
                const lat = e.latlng.lat;
                const lon = e.latlng.lng;

                // Hide guide overlay
                document.getElementById('guideOverlay').classList.add('hidden');

                // Remember where user clicked (name filled after reverse geocode)
                pendingClickLocation = { lat, lon, name: '' };

                // Remove existing preview marker if any (keep work location marker)
                if (previewMarker) {
                    map.removeLayer(previewMarker);
                    previewMarker = null;
                }

                // Drop a temporary preview pin (keep existing work location marker visible)
                previewMarker = L.marker([lat, lon], { draggable: false }).addTo(map);
                previewMarker.bindPopup('Loading location').openPopup();
                map.setView([lat, lon], 17);

                // Reverse geocode to get address and update popup + confirmation card
                reverseGeocode(lat, lon).then(locationName => {
                    showLocationPopup(lat, lon, locationName);

                    const name = locationName || 'Selected location';
                    const latText = lat.toFixed(4);
                    const lngText = lon.toFixed(4);
                    const html = `<strong>Selected Location</strong><br>${name}<br><small>Lat: ${latText}, Lng: ${lngText}</small><br><em>Select location type and confirm.</em>`;
                    if (previewMarker) {
                        previewMarker.bindPopup(html).openPopup();
                    }
                });
            }
        });

        // Update button text based on selected location type
        function updateLocationButtonText() {
            const locationTypeSelect = document.getElementById('locationTypeSelect');
            const locationTypeCustom = document.getElementById('locationTypeCustom');
            const confirmBtn = document.getElementById('confirmLocationBtn');
            
            if (locationTypeSelect && confirmBtn) {
                const locationType = locationTypeSelect.value;
                
                // Show/hide custom input based on selection
                if (locationType === 'Others') {
                    if (locationTypeCustom) {
                        locationTypeCustom.style.display = 'block';
                        locationTypeCustom.focus();
                    }
                } else {
                    if (locationTypeCustom) {
                        locationTypeCustom.style.display = 'none';
                        locationTypeCustom.value = '';
                    }
                }
                
                // Button text is always "Pin Location"
                confirmBtn.textContent = 'Pin Location';
            }
        }

        // Show location confirmation popup with address & coordinates
        function showLocationPopup(lat, lon, locationName) {
            const popup = document.getElementById('locationPopup');
            const label = locationName || 'Selected location';

            const latText = lat.toFixed(4);
            const lngText = lon.toFixed(4);

            // Update location name
            const labelEl = document.getElementById('popupLocationName');
            if (labelEl) {
                labelEl.textContent = label;
            }

            // Update coordinates
            const coordsEl = document.getElementById('popupLocationCoords');
            if (coordsEl) {
                coordsEl.textContent = `Lat: ${latText}, Lng: ${lngText}`;
            }

            // Initialize location type select (default to existing type or 'Work')
            const locationTypeSelect = document.getElementById('locationTypeSelect');
            const locationTypeCustom = document.getElementById('locationTypeCustom');
            const currentType = questionnaireData.locationType || 'Work';
            
            if (locationTypeSelect) {
                // Check if current type is one of the standard options
                const standardTypes = ['Work', 'School', 'Home', 'Preferred'];
                if (standardTypes.includes(currentType)) {
                    locationTypeSelect.value = currentType;
                } else {
                    // It's a custom type, set to "Others" and populate custom input
                    locationTypeSelect.value = 'Others';
                    if (locationTypeCustom) {
                        locationTypeCustom.value = currentType;
                        locationTypeCustom.style.display = 'block';
                    }
                }
                updateLocationButtonText();
            }

            // Store latest readable name for confirmation
            if (pendingClickLocation) {
                pendingClickLocation.name = label;
            }

            // Position popup near click location
            const point = map.latLngToContainerPoint([lat, lon]);
            popup.style.left = (point.x + 20) + 'px';
            popup.style.top = (point.y - 10) + 'px';
            popup.style.display = 'block';
            popup.classList.remove('hidden');

            // Show spotlight on popup if in tutorial mode
            if (tutorialMode) {
                setTimeout(() => {
                    showTutorialOverlayLocationPopup();
                }, 100); // Small delay to ensure popup is positioned
            }
        }

        function showTutorialOverlayLocationPopup() {
            const overlay = document.getElementById('tutorialOverlay');
            const spotlight = document.getElementById('tutorialSpotlight');
            const tooltip = document.getElementById('tutorialTooltip');
            const locationPopup = document.getElementById('locationPopup');
            const confirmBtn = document.querySelector('.popup-btn-confirm');

            if (!overlay || !locationPopup || !confirmBtn) return;

            // Function to update positions
            const updatePositions = () => {
                // Get location popup position
                const rect = locationPopup.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate spotlight position (center on location popup)
                // Make spotlight large enough to cover the entire popup
                const spotlightSize = Math.max(300, Math.max(rect.width, rect.height) / 2 + 50);
                const spotlightX = centerX;
                const spotlightY = centerY;

                // Update spotlight mask to center on location popup
                spotlight.style.maskImage = `radial-gradient(ellipse ${spotlightSize}px ${spotlightSize * 0.8}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 80}px)`;
                spotlight.style.webkitMaskImage = `radial-gradient(ellipse ${spotlightSize}px ${spotlightSize * 0.8}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize}px, black ${spotlightSize + 80}px)`;

                // Position tooltip above location popup
                tooltip.style.left = `${centerX}px`;
                tooltip.style.top = `${Math.max(20, rect.top - 100)}px`;
                tooltip.style.transform = 'translate(-50%, 0)';
                tooltip.className = 'tutorial-tooltip arrow-down';
                tooltip.querySelector('.tutorial-tooltip-text').textContent = 'Click "Set as Work Location" to confirm your selection.';
            };

            // Initial position update
            updatePositions();

            // Show overlay (or update if already visible)
            if (overlay.classList.contains('hidden')) {
                overlay.classList.remove('hidden');
                setTimeout(() => {
                    overlay.classList.add('active');
                    updatePositions();
                }, 10);
            } else {
                // Overlay is already visible, just update positions
                overlay.classList.add('active');
                setTimeout(() => {
                    updatePositions();
                }, 50);
            }

            // Update positions on window resize
            // Remove old handler if exists
            if (overlay._resizeHandler) {
                window.removeEventListener('resize', overlay._resizeHandler);
            }
            const resizeHandler = () => {
                if (overlay.classList.contains('active')) {
                    updatePositions();
                }
            };
            window.addEventListener('resize', resizeHandler);
            overlay._resizeHandler = resizeHandler;

            // Lock all UI except location popup
            document.body.classList.add('tutorial-locked');

            // Highlight the confirm button
            confirmBtn.style.border = '3px solid var(--primary-color)';
            confirmBtn.style.boxShadow = '0 0 0 4px rgba(37, 99, 235, 0.2)';
            confirmBtn.style.animation = 'pulseHighlight 2s infinite';
        }

        // Confirm location: commit the selected point as the official work location
        function confirmLocation() {
            if (!pendingClickLocation) return;

            const name = pendingClickLocation.name || questionnaireData.workLocation || 'Location';
            const lat = pendingClickLocation.lat;
            const lon = pendingClickLocation.lon;

            // Get selected location type
            const locationTypeSelect = document.getElementById('locationTypeSelect');
            const locationTypeCustom = document.getElementById('locationTypeCustom');
            let locationType = locationTypeSelect ? locationTypeSelect.value : 'Work';
            
            // If "Others" is selected, use the custom input value
            if (locationType === 'Others' && locationTypeCustom && locationTypeCustom.value.trim()) {
                locationType = locationTypeCustom.value.trim();
            }

            // Remove preview marker
            if (previewMarker) {
                previewMarker.closePopup();
                map.removeLayer(previewMarker);
                previewMarker = null;
            }

            // Add new location marker
            placeMarker(lat, lon, name, locationType);

            // Hide the confirmation popup
            const popupEl = document.getElementById('locationPopup');
            if (popupEl) {
                popupEl.classList.add('hidden');
                popupEl.style.display = 'none';
            }

            // Reset location type select to default for next pin
            if (locationTypeSelect) {
                locationTypeSelect.value = 'Work';
            }
            if (locationTypeCustom) {
                locationTypeCustom.style.display = 'none';
                locationTypeCustom.value = '';
            }
            updateLocationButtonText();

            // Add class to body to enable budget section interaction
            document.body.classList.add('work-location-set');

            pendingClickLocation = null;

            // Update guide text
            const guideTextEl = document.getElementById('currentGuide');
            if (guideTextEl) {
                guideTextEl.textContent = ' Location pinned! You can drag the pin to adjust. Click Next to continue.';
            }

            // Enable next button
            const nextBtn2 = document.getElementById('nextBtn2');
            if (nextBtn2) {
                nextBtn2.disabled = false;
            }

            // Hide tutorial overlay and remove button highlight if in tutorial mode
            if (tutorialMode) {
                hideTutorialOverlay();
                const confirmBtn = document.querySelector('.popup-btn-confirm');
                if (confirmBtn) {
                    confirmBtn.style.border = '';
                    confirmBtn.style.boxShadow = '';
                    confirmBtn.style.animation = '';
                }
                
                // Show spotlight on budget section after work location is set
                setTimeout(() => {
                    const firstLocation = getFirstLocation();
                    if (currentStep === 2 && firstLocation && tutorialMode) {
                        showTutorialOverlayBudget();
                    }
                }, 300);
            }
        }

        function showTutorialOverlayBudget() {
            const overlay = document.getElementById('tutorialOverlay');
            const spotlight = document.getElementById('tutorialSpotlight');
            const tooltip = document.getElementById('tutorialTooltip');
            const budgetSection = document.querySelector('.locations-budget');

            if (!overlay || !spotlight || !tooltip || !budgetSection) {
                console.log('Budget overlay: Missing elements', { 
                    overlay: !!overlay, 
                    spotlight: !!spotlight,
                    tooltip: !!tooltip,
                    budgetSection: !!budgetSection 
                });
                return;
            }

            // Function to update positions
            const updatePositions = () => {
                // Get budget section position
                const rect = budgetSection.getBoundingClientRect();
                
                // Check if budget section is visible
                if (rect.width === 0 || rect.height === 0) {
                    console.log('Budget section not visible, retrying...');
                    setTimeout(updatePositions, 100);
                    return;
                }
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate spotlight position (center on budget section)
                const spotlightSize = Math.max(350, Math.max(rect.width, rect.height) / 2 + 50);
                const spotlightX = centerX;
                const spotlightY = centerY;

                // Update spotlight mask to center on budget section
                // Use a larger transparent area for better visibility
                const maskGradient = `radial-gradient(ellipse ${spotlightSize}px ${spotlightSize * 0.8}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize * 0.9}px, black ${spotlightSize + 60}px)`;
                spotlight.style.maskImage = maskGradient;
                spotlight.style.webkitMaskImage = maskGradient;
                
                // Debug: Log the values
                console.log('Budget spotlight:', {
                    centerX, centerY, spotlightX, spotlightY, spotlightSize,
                    rect: { width: rect.width, height: rect.height, left: rect.left, top: rect.top }
                });

                // Position tooltip above budget section
                tooltip.style.left = `${centerX}px`;
                tooltip.style.top = `${Math.max(20, rect.top - 100)}px`;
                tooltip.style.transform = 'translate(-50%, 0)';
                tooltip.className = 'tutorial-tooltip arrow-down';
                const tooltipText = tooltip.querySelector('.tutorial-tooltip-text');
                if (tooltipText) {
                    tooltipText.textContent = 'Set your budget range to continue.';
                }
            };

            // Lock UI and highlight budget section first
            document.body.classList.add('tutorial-locked');
            budgetSection.style.border = '3px solid var(--primary-color)';
            budgetSection.style.borderRadius = '12px';
            budgetSection.style.padding = '0.75rem';
            budgetSection.style.background = 'rgba(37, 99, 235, 0.05)';
            budgetSection.style.boxShadow = '0 0 0 4px rgba(37, 99, 235, 0.1)';
            
            // Reset and ensure spotlight is visible and has proper styling
            spotlight.style.display = 'block';
            spotlight.style.position = 'absolute';
            spotlight.style.top = '0';
            spotlight.style.left = '0';
            spotlight.style.width = '100%';
            spotlight.style.height = '100%';
            spotlight.style.background = 'rgba(0, 0, 0, 0.6)';
            spotlight.style.pointerEvents = 'none';
            // Reset mask initially (will be set in updatePositions)
            spotlight.style.maskImage = 'none';
            spotlight.style.webkitMaskImage = 'none';
            
            // Show overlay and ensure it's visible
            overlay.classList.remove('hidden');
            overlay.style.display = 'block';
            
            setTimeout(() => {
                overlay.classList.add('active');
                // Wait for layout to settle, then update positions
                setTimeout(() => {
                    updatePositions();
                    // Double-check positions after a short delay
                    setTimeout(updatePositions, 50);
                }, 150);
            }, 50);

            // Update positions on window resize
            // Remove old handler if exists
            if (overlay._resizeHandler) {
                window.removeEventListener('resize', overlay._resizeHandler);
            }
            const resizeHandler = () => {
                if (overlay.classList.contains('active')) {
                    updatePositions();
                }
            };
            window.addEventListener('resize', resizeHandler);
            overlay._resizeHandler = resizeHandler;
        }

        function showTutorialOverlayStartAnalysis() {
            const overlay = document.getElementById('tutorialOverlay');
            const spotlight = document.getElementById('tutorialSpotlight');
            const tooltip = document.getElementById('tutorialTooltip');
            const startAnalysisBtn = document.querySelector('.start-analysis-btn');

            if (!overlay || !spotlight || !tooltip || !startAnalysisBtn) {
                console.log('Start Analysis overlay: Missing elements', { 
                    overlay: !!overlay, 
                    spotlight: !!spotlight,
                    tooltip: !!tooltip,
                    startAnalysisBtn: !!startAnalysisBtn 
                });
                return;
            }

            // Function to update positions
            const updatePositions = () => {
                // Get Start Analysis button position
                const rect = startAnalysisBtn.getBoundingClientRect();
                
                // Check if button is visible
                if (rect.width === 0 || rect.height === 0) {
                    console.log('Start Analysis button not visible, retrying...');
                    setTimeout(updatePositions, 100);
                    return;
                }
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate spotlight position (center on button)
                const spotlightSize = Math.max(200, Math.max(rect.width, rect.height) / 2 + 80);
                const spotlightX = centerX;
                const spotlightY = centerY;

                // Update spotlight mask to center on button
                const maskGradient = `radial-gradient(circle ${spotlightSize}px at ${spotlightX}px ${spotlightY}px, transparent 0px, transparent ${spotlightSize * 0.9}px, black ${spotlightSize + 60}px)`;
                spotlight.style.maskImage = maskGradient;
                spotlight.style.webkitMaskImage = maskGradient;
                
                // Position tooltip above button
                tooltip.style.left = `${centerX}px`;
                tooltip.style.top = `${Math.max(20, rect.top - 100)}px`;
                tooltip.style.transform = 'translate(-50%, 0)';
                tooltip.className = 'tutorial-tooltip arrow-down';
                const tooltipText = tooltip.querySelector('.tutorial-tooltip-text');
                if (tooltipText) {
                    tooltipText.textContent = 'Click "Start Analysis" to see your property recommendations.';
                }
            };

            // Clean up budget section highlight
            const budgetSection = document.querySelector('.locations-budget');
            if (budgetSection) {
                budgetSection.style.border = '';
                budgetSection.style.borderRadius = '';
                budgetSection.style.padding = '';
                budgetSection.style.background = '';
                budgetSection.style.boxShadow = '';
            }

            // Lock UI and highlight Start Analysis button first
            document.body.classList.add('tutorial-locked');
            startAnalysisBtn.style.border = '3px solid var(--primary-color)';
            startAnalysisBtn.style.borderRadius = '10px';
            startAnalysisBtn.style.boxShadow = '0 0 0 4px rgba(37, 99, 235, 0.2)';
            startAnalysisBtn.style.animation = 'pulseHighlight 2s infinite';
            
            // Reset and ensure spotlight is visible and has proper styling
            spotlight.style.display = 'block';
            spotlight.style.position = 'absolute';
            spotlight.style.top = '0';
            spotlight.style.left = '0';
            spotlight.style.width = '100%';
            spotlight.style.height = '100%';
            spotlight.style.background = 'rgba(0, 0, 0, 0.6)';
            spotlight.style.pointerEvents = 'none';
            // Reset mask initially (will be set in updatePositions)
            spotlight.style.maskImage = 'none';
            spotlight.style.webkitMaskImage = 'none';
            
            // Show overlay and ensure it's visible
            overlay.classList.remove('hidden');
            overlay.style.display = 'block';
            
            setTimeout(() => {
                overlay.classList.add('active');
                // Wait for layout to settle, then update positions
                setTimeout(() => {
                    updatePositions();
                    // Double-check positions after a short delay
                    setTimeout(updatePositions, 50);
                }, 150);
            }, 50);

            // Update positions on window resize
            // Remove old handler if exists
            if (overlay._resizeHandler) {
                window.removeEventListener('resize', overlay._resizeHandler);
            }
            const resizeHandler = () => {
                if (overlay.classList.contains('active')) {
                    updatePositions();
                }
            };
            window.addEventListener('resize', resizeHandler);
            overlay._resizeHandler = resizeHandler;
        }

        // Cancel location
        function cancelLocation() {
            const popupEl = document.getElementById('locationPopup');
            if (popupEl) {
                popupEl.classList.add('hidden');
                popupEl.style.display = 'none';
            }

            // Remove preview marker if it exists and close its popup (keep work location marker)
            if (previewMarker) {
                previewMarker.closePopup();
                map.removeLayer(previewMarker);
                previewMarker = null;
            }

            // Clear pending location
            pendingClickLocation = null;

            // Hide tutorial overlay and remove button highlight if in tutorial mode
            if (tutorialMode) {
                hideTutorialOverlay();
                const confirmBtn = document.querySelector('.popup-btn-confirm');
                if (confirmBtn) {
                    confirmBtn.style.border = '';
                    confirmBtn.style.boxShadow = '';
                    confirmBtn.style.animation = '';
                }
            }
        }

        const API_BASE = 'https://propertyzap-em0g.onrender.com';

        // Render pinned locations list (all pinned locations)
        function renderPinnedLocations() {
            const list = document.getElementById('pinnedLocationsList');
            if (!list) return;

            list.innerHTML = '';

            if (!questionnaireData.locations || questionnaireData.locations.length === 0) {
                const empty = document.createElement('p');
                empty.className = 'location-empty';
                empty.textContent = 'No locations pinned! Search and pin your location on the map.';
                list.appendChild(empty);
                return;
            }

            questionnaireData.locations.forEach(location => {
                const item = document.createElement('div');
                item.className = 'location-item';

                const name = location.name || 'Location';
                const locationType = location.locationType || 'Work';
                const lat = typeof location.lat === 'number' ? location.lat.toFixed(4) : '';
                const lng = typeof location.lng === 'number' ? location.lng.toFixed(4) : '';
                const opacity = typeof location.opacity === 'number' ? location.opacity : 0.2;

                // Only show opacity control if analysis circles have been drawn
                const showOpacityControl = analysisCircles.length > 0;
                
                item.innerHTML = `
                    <button type="button" class="location-delete-btn" onclick="removeLocation('${location.id}')" title="Remove location"></button>
                    <div>
                        <div class="location-name"><span style="font-weight: 600; color: var(--primary-color);">${locationType}:</span> ${name}</div>
                        <div class="location-coords">${lat && lng ? `Lat: ${lat}, Lng: ${lng}` : ''}</div>
                        ${showOpacityControl ? `
                        <div class="location-opacity-control">
                            <span class="location-opacity-label">Opacity:</span>
                            <input type="range" 
                                   class="location-opacity-slider" 
                                   id="opacitySlider_${location.id}"
                                   min="0" 
                                   max="1" 
                                   step="0.01" 
                                   value="${opacity}"
                                   oninput="updateLocationOpacity('${location.id}', this.value)">
                            <span class="location-opacity-value" id="opacityValue_${location.id}">${Math.round(opacity * 100)}%</span>
                        </div>
                        ` : ''}
                    </div>
                `;

                list.appendChild(item);
            });
        }

        // Persist questionnaire data (including pinned locations) to localStorage
        function saveQuestionnaireToStorage() {
            try {
                localStorage.setItem('propertyzap_questionnaire', JSON.stringify(questionnaireData));
            } catch (e) {
                console.warn('Error saving questionnaire data to storage:', e);
            }
        }

        // Persist pinned locations to backend user database
        async function savePinnedLocationsToBackend() {
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) return;

                const payload = {
                    pinnedLocations: questionnaireData.locations || []
                };

                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!res.ok) {
                    console.warn('Failed to save pinned locations to backend');
                }
            } catch (e) {
                console.warn('Error saving pinned locations to backend:', e);
            }
        }

        // Place marker on map (adds a new location)
        function placeMarker(lat, lon, locationName = null, locationType = null) {
            // Generate unique ID for this location
            const locationId = `loc_${Date.now()}_${locationIdCounter++}`;
            
            // Use provided location type or default
            const finalLocationType = locationType || 'Work';
            const finalLocationName = locationName || 'Location';
            
            // Create new marker
            const marker = L.marker([lat, lon], { draggable: true }).addTo(map);
            
            // Add popup
            const latText = lat.toFixed(4);
            const lngText = lon.toFixed(4);
            marker.bindPopup(`<strong>${finalLocationType} Location:</strong><br>${finalLocationName}<br><small>Lat: ${latText}, Lng: ${lngText}</small>`).openPopup();
            
            // Store marker reference
            locationMarkers.set(locationId, marker);
            
            // Add to questionnaire data
            const locationData = {
                id: locationId,
                name: finalLocationName,
                lat: lat,
                lng: lon,
                locationType: finalLocationType,
                opacity: 0.2 // Default opacity for radius circles
            };
            questionnaireData.locations.push(locationData);
            
            // Update on drag
            marker.on('dragend', function(e) {
                const position = marker.getLatLng();
                const updatedLocation = questionnaireData.locations.find(loc => loc.id === locationId);
                if (updatedLocation) {
                    updatedLocation.lat = position.lat;
                    updatedLocation.lng = position.lng;
                    
                    // Reverse geocode to update location name
                    reverseGeocode(position.lat, position.lng).then((newLocationName) => {
                        updatedLocation.name = newLocationName;
                        const latText = position.lat.toFixed(4);
                        const lngText = position.lng.toFixed(4);
                        const html = `<strong>${updatedLocation.locationType} Location</strong><br>${newLocationName}<br><small>Lat: ${latText}, Lng: ${lngText}</small>`;
                        marker.bindPopup(html);
                        renderPinnedLocations();
                    });
                }
            });
            
            // Center map on marker (more zoomed in)
            map.setView([lat, lon], 17);
            
            // Update sidebar list
            renderPinnedLocations();
            // Persist changes
            saveQuestionnaireToStorage();
            savePinnedLocationsToBackend();
            
            return locationId;
        }

        // Reverse geocode to get location name from coordinates
        // Returns location name only - does NOT update sidebar or questionnaire data
        async function reverseGeocode(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`);
                const data = await response.json();
                
                if (data && data.display_name) {
                    const locationName = data.address.road || data.address.suburb || data.address.city || data.display_name.split(',')[0];
                    return locationName;
                }
            } catch (error) {
                console.error('Reverse geocode error:', error);
            }
            return 'Selected Location';
        }

        // Remove a specific location by ID
        function removeLocation(locationId) {
            // Remove marker from map
            const marker = locationMarkers.get(locationId);
            if (marker) {
                map.removeLayer(marker);
                locationMarkers.delete(locationId);
            }
            
            // Remove circles from map
            const circles = locationCirclesMap.get(locationId);
            if (circles) {
                circles.forEach(circle => map.removeLayer(circle));
                locationCirclesMap.delete(locationId);
                // Also remove from analysisCircles array
                analysisCircles = analysisCircles.filter(c => !circles.includes(c));
            }
            
            // Remove from questionnaire data
            questionnaireData.locations = questionnaireData.locations.filter(loc => loc.id !== locationId);
            
            // Update sidebar list
            renderPinnedLocations();
            // Persist changes
            saveQuestionnaireToStorage();
            savePinnedLocationsToBackend();
            
            // If no locations left, remove work-location-set class
            if (questionnaireData.locations.length === 0) {
                document.body.classList.remove('work-location-set');
                document.body.classList.remove('budget-set');
                
                const workLocationInput = document.getElementById('workLocation');
                if (workLocationInput) {
                    workLocationInput.value = '';
                }
            }
        }
        
        // Clear all pinned locations (legacy function for compatibility)
        function clearWorkLocation() {
            // Remove all markers
            locationMarkers.forEach((marker, locationId) => {
                map.removeLayer(marker);
            });
            locationMarkers.clear();
            
            // Clear all locations
            questionnaireData.locations = [];
            
            // Remove work-location-set and budget-set classes
            document.body.classList.remove('work-location-set');
            document.body.classList.remove('budget-set');

            const workLocationInput = document.getElementById('workLocation');
            if (workLocationInput) {
                workLocationInput.value = '';
            }

            const nextBtn2 = document.getElementById('nextBtn2');
            if (nextBtn2) {
                nextBtn2.disabled = true;
            }

            renderPinnedLocations();
            saveQuestionnaireToStorage();
            savePinnedLocationsToBackend();
            saveQuestionnaireToStorage();
        }

        // Allow Enter key to search (only after guide is dismissed)
        document.getElementById('locationSearch').addEventListener('keypress', function(e) {
            if (guideStep === 1) {
                // Force user to acknowledge the guide before typing/searching
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                searchLocation();
            }
        });

        // Sync sidebar min/max budget with questionnaire data
        const sidebarBudgetMin = document.getElementById('sidebarBudgetMin');
        const sidebarBudgetMax = document.getElementById('sidebarBudgetMax');
        if (sidebarBudgetMin && sidebarBudgetMax) {
            sidebarBudgetMin.addEventListener('change', function () {
                questionnaireData.minBudget = this.value;
                // Show spotlight on Start Analysis button if both budget values are set and tutorial mode is on
                if (tutorialMode && this.value && sidebarBudgetMax.value) {
                    // Add budget-set class to enable button interaction
                    document.body.classList.add('budget-set');
                    setTimeout(() => {
                        showTutorialOverlayStartAnalysis();
                    }, 300);
                } else if (tutorialMode && (!this.value || !sidebarBudgetMax.value)) {
                    // Remove budget-set class if budget is not fully set
                    document.body.classList.remove('budget-set');
                }
            });
            sidebarBudgetMax.addEventListener('change', function () {
                questionnaireData.maxBudget = this.value;
                // Show spotlight on Start Analysis button if both budget values are set and tutorial mode is on
                if (tutorialMode && this.value && sidebarBudgetMin.value) {
                    // Add budget-set class to enable button interaction
                    document.body.classList.add('budget-set');
                    setTimeout(() => {
                        showTutorialOverlayStartAnalysis();
                    }, 300);
                } else if (tutorialMode && (!this.value || !sidebarBudgetMin.value)) {
                    // Remove budget-set class if budget is not fully set
                    document.body.classList.remove('budget-set');
                }
            });
        }

        // Add event listeners for investment filters to trigger re-filtering
        const sidebarInvestmentType = document.getElementById('sidebarInvestmentType');
        const sidebarMinimumROI = document.getElementById('sidebarMinimumROI');
        const advancedInvestmentType = document.getElementById('advancedInvestmentType');
        const advancedMinimumROI = document.getElementById('advancedMinimumROI');
        const advancedPropertySizeMin = document.getElementById('advancedPropertySizeMin');
        const advancedPropertySizeMax = document.getElementById('advancedPropertySizeMax');
        
        // Standard filter event listeners
        if (sidebarInvestmentType) {
            sidebarInvestmentType.addEventListener('change', function() {
                // Re-filter condos when investment type changes
                if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                    fetchAndPlotCondos();
                }
            });
        }
        
        if (sidebarMinimumROI) {
            sidebarMinimumROI.addEventListener('input', function() {
                // Re-filter condos when minimum ROI changes (debounce for performance)
                clearTimeout(window.minimumROIDebounce);
                window.minimumROIDebounce = setTimeout(() => {
                    if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                        fetchAndPlotCondos();
                    }
                }, 500); // Wait 500ms after user stops typing
            });
        }
        
        // Advanced filter event listeners
        if (advancedInvestmentType) {
            advancedInvestmentType.addEventListener('change', function() {
                // Re-filter condos when advanced investment type changes
                if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                    fetchAndPlotCondos();
                }
            });
        }
        
        if (advancedMinimumROI) {
            advancedMinimumROI.addEventListener('input', function() {
                // Re-filter condos when advanced minimum ROI changes (debounce for performance)
                clearTimeout(window.advancedMinimumROIDebounce);
                window.advancedMinimumROIDebounce = setTimeout(() => {
                    if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                        fetchAndPlotCondos();
                    }
                }, 500); // Wait 500ms after user stops typing
            });
        }
        
        if (advancedPropertySizeMin) {
            advancedPropertySizeMin.addEventListener('change', function() {
                // Re-filter condos when advanced property size min changes
                if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                    fetchAndPlotCondos();
                }
            });
        }
        
        if (advancedPropertySizeMax) {
            advancedPropertySizeMax.addEventListener('change', function() {
                // Re-filter condos when advanced property size max changes
                if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                    fetchAndPlotCondos();
                }
            });
        }

        // Advanced filter state
        let advancedFilterEnabled = false;

        // Update filters visibility based on buyer type
        function updateFiltersByBuyerType(purpose, qData) {
            const propertySizeFilter = document.getElementById('propertySizeFilter');
            const investmentTypeFilter = document.getElementById('investmentTypeFilter');
            const minimumROIFilter = document.getElementById('minimumROIFilter');
            
            // Advanced filter sections (positioned after Advanced Filter button)
            const advancedPropertySizeFilter = document.getElementById('advancedPropertySizeFilter');
            const advancedInvestmentTypeFilter = document.getElementById('advancedInvestmentTypeFilter');
            const advancedMinimumROIFilter = document.getElementById('advancedMinimumROIFilter');
            
            // Hide all standard filters first
            if (propertySizeFilter) propertySizeFilter.style.display = 'none';
            if (investmentTypeFilter) investmentTypeFilter.style.display = 'none';
            if (minimumROIFilter) minimumROIFilter.style.display = 'none';
            
            // Hide all advanced filters first
            if (advancedPropertySizeFilter) advancedPropertySizeFilter.style.display = 'none';
            if (advancedInvestmentTypeFilter) advancedInvestmentTypeFilter.style.display = 'none';
            if (advancedMinimumROIFilter) advancedMinimumROIFilter.style.display = 'none';
            
            // Show standard filters based on buyer type
            if (purpose === 'own-stay') {
                // Show Budget Range and Property Size
                if (propertySizeFilter) propertySizeFilter.style.display = 'block';
                
                // Show advanced filters if enabled (Investment Type and Minimum ROI)
                if (advancedFilterEnabled) {
                    if (advancedInvestmentTypeFilter) advancedInvestmentTypeFilter.style.display = 'block';
                    if (advancedMinimumROIFilter) advancedMinimumROIFilter.style.display = 'block';
                }
            } else if (purpose === 'investment') {
                // Show Budget Range, Preferred Investment Type, and Minimum ROI
                if (investmentTypeFilter) investmentTypeFilter.style.display = 'block';
                if (minimumROIFilter) minimumROIFilter.style.display = 'block';
                
                // Show advanced filters if enabled (Property Size - positioned after Advanced Filter button)
                if (advancedFilterEnabled) {
                    if (advancedPropertySizeFilter) advancedPropertySizeFilter.style.display = 'block';
                }
                
                // Load investment data from questionnaire
                if (qData && qData.purposeData) {
                    const investmentType = qData.purposeData.investmentType;
                    const minimumROI = qData.purposeData.minimumROI;
                    
                    const sidebarInvestmentType = document.getElementById('sidebarInvestmentType');
                    const sidebarMinimumROI = document.getElementById('sidebarMinimumROI');
                    const advancedInvestmentType = document.getElementById('advancedInvestmentType');
                    const advancedMinimumROI = document.getElementById('advancedMinimumROI');
                    
                    if (investmentType) {
                        if (sidebarInvestmentType) sidebarInvestmentType.value = investmentType;
                        if (advancedInvestmentType) advancedInvestmentType.value = investmentType;
                    }
                    if (minimumROI !== null && minimumROI !== undefined) {
                        if (sidebarMinimumROI) sidebarMinimumROI.value = minimumROI;
                        if (advancedMinimumROI) advancedMinimumROI.value = minimumROI;
                    }
                }
            }
        }

        // Toggle advanced filter
        function toggleAdvancedFilter() {
            advancedFilterEnabled = !advancedFilterEnabled;
            const icon = document.getElementById('advancedFilterIcon');
            // Get purpose from questionnaireData or try to infer from localStorage
            let purpose = questionnaireData.purpose || '';
            if (!purpose) {
                const questionnaireDataStr = localStorage.getItem('propertyzap_questionnaire');
                if (questionnaireDataStr) {
                    try {
                        const qData = JSON.parse(questionnaireDataStr);
                        purpose = qData.purpose || 'own-stay';
                    } catch (e) {
                        purpose = 'own-stay';
                    }
                } else {
                    purpose = 'own-stay';
                }
            }
            
            if (icon) {
                icon.textContent = advancedFilterEnabled ? '' : '';
                icon.style.transform = advancedFilterEnabled ? 'rotate(180deg)' : 'rotate(0deg)';
            }
            
            // Reload questionnaire data to update filters
            const questionnaireDataStr = localStorage.getItem('propertyzap_questionnaire');
            if (questionnaireDataStr) {
                try {
                    const qData = JSON.parse(questionnaireDataStr);
                    updateFiltersByBuyerType(purpose, qData);
                } catch (e) {
                    console.error('Error parsing questionnaire data:', e);
                    updateFiltersByBuyerType(purpose, null);
                }
            } else {
                updateFiltersByBuyerType(purpose, null);
            }
        }

        // Initialize advanced filter toggle
        function initAdvancedFilter() {
            const advancedFilterToggle = document.getElementById('advancedFilterToggle');
            if (advancedFilterToggle) {
                advancedFilterToggle.addEventListener('click', toggleAdvancedFilter);
            }
        }
        
        // Initialize tutorial toggle after DOM is ready
        initUserProfile();
        initTutorialToggle();
        initAdvancedFilter();

        // Reload user profile info when page becomes visible (e.g., returning from user-profile.html)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                loadUserProfileInfo();
            }
        });

        // Also reload when window gains focus
        window.addEventListener('focus', function() {
            loadUserProfileInfo();
        });

        // Draw 4 concentric analysis circles around the current work location
        function drawAnalysisCircles() {
            if (!questionnaireData.locations || questionnaireData.locations.length === 0) {
                alert('Please pin at least one location on the map first.');
                return;
            }

            // Clear any existing circles
            analysisCircles.forEach(c => map.removeLayer(c));
            analysisCircles = [];
            locationCirclesMap.clear();

            // Define radii and styles.
            // Inner 3km is filled; outer rings are outlines only so colors don't muddy each other.
            const rings = [
                { radius: 12000, color: '#ef4444', weight: 2 }, // 12 km (outline)
                { radius: 9000,  color: '#f97316', weight: 2 }, // 9 km (outline)
                { radius: 6000,  color: '#3b82f6', weight: 2 }, // 6 km (outline)  - yellow 
                { radius: 3000,  color: '#22c55e', weight: 2 }, // 3 km (solid-ish)
            ];

            // Draw circles for each pinned location
            questionnaireData.locations.forEach((location, index) => {
                const center = [location.lat, location.lng];
                const opacity = typeof location.opacity === 'number' ? location.opacity : 0.2;
                const locationCircles = [];
                
                rings.forEach(({ radius, color, weight }) => {
                    const circle = L.circle(center, {
                        radius,
                        color,
                        weight,
                        fillColor: color,
                        fillOpacity: opacity,
                        dashArray: '4,6'
                    }).addTo(map);
                    analysisCircles.push(circle);
                    locationCircles.push(circle);
                });
                
                // Store circles for this location so we can update them individually
                locationCirclesMap.set(location.id, locationCircles);
            });
        }
        
        // Update opacity for a specific location's circles
        function updateLocationOpacity(locationId, opacityValue) {
            const opacity = parseFloat(opacityValue);
            if (isNaN(opacity)) return;
            
            // Update the location data
            const location = questionnaireData.locations.find(loc => loc.id === locationId);
            if (location) {
                location.opacity = opacity;
            }
            
            // Update the circles on the map
            const circles = locationCirclesMap.get(locationId);
            if (circles) {
                circles.forEach(circle => {
                    circle.setStyle({ fillOpacity: opacity });
                });
            }
            
            // Update the display value
            const valueDisplay = document.getElementById(`opacityValue_${locationId}`);
            if (valueDisplay) {
                valueDisplay.textContent = Math.round(opacity * 100) + '%';
            }
        }

        // Start analysis from sidebar button
        function startSidebarAnalysis() {
            // Always hide tutorial overlay and unlock UI (regardless of tutorial mode)
            hideTutorialOverlay();
            
            // Ensure UI is fully unlocked
            document.body.classList.remove('tutorial-locked');
            document.body.classList.remove('work-location-set');
            document.body.classList.remove('budget-set');
            
            // Remove all highlights
            const startAnalysisBtn = document.querySelector('.start-analysis-btn');
            if (startAnalysisBtn) {
                startAnalysisBtn.style.border = '';
                startAnalysisBtn.style.boxShadow = '';
                startAnalysisBtn.style.animation = '';
            }
            
            // Ensure overlay is completely hidden
            const overlay = document.getElementById('tutorialOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
                overlay.classList.remove('active');
                overlay.style.display = 'none';
            }

            // Scroll to map area (keep current zoom/center)
            const wrapper = document.querySelector('.map-wrapper');
            if (wrapper) {
                window.scrollTo({ top: wrapper.offsetTop - 80, behavior: 'smooth' });
            }

            // Check if work location is set
            const firstLocation = getFirstLocation();
            if (!firstLocation) {
                alert('Please pin at least one location first.');
                return;
            }

            // Center map on first location and zoom to show 12km radius
            // Approximate zoom level to show 12km radius (roughly zoom level 12-13)
            map.setView([firstLocation.lat, firstLocation.lng], 12.2);

            // Draw analysis circles around the pinned work location
            drawAnalysisCircles();
            
            // Re-render locations to show opacity controls
            renderPinnedLocations();
            
            // Show condos panel immediately with loading state
            const condosPanel = document.getElementById('condosPanel');
            const condosList = document.getElementById('condosList');
            if (condosPanel && condosList) {
                condosPanel.style.display = 'block';
                condosList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-light);"><div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">Analyzing...</div><div style="font-size: 0.85rem;">Finding condos within 12km radius</div></div>';
            }
            
            // Fetch and plot condos within the radius
            fetchAndPlotCondos();
        }

        // Calculate distance between two lat/lng points in meters (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in meters
        }

        // Categorize condo into distance band
        function getDistanceBand(distanceMeters) {
            if (distanceMeters <= 3000) return '0to3';
            if (distanceMeters <= 6000) return '3to6';
            if (distanceMeters <= 9000) return '6to9';
            if (distanceMeters <= 12000) return '9to12';
            return null; // Outside 12km
        }

        // Store CSV condo data
        let csvCondos = [];
        
        // Store past transaction data, keyed by Negeri+Daerah+Mukim+Seksyen+Lot
        let pastTransactions = new Map();
        
        // Store all ads data, keyed by Negeri+Daerah+Mukim+Seksyen+Lot
        // Each entry contains { minSalePrice: number|null, minRentPrice: number|null }
        let allAds = new Map();
        
        // Store Airbnb listing data
        let airbnbListings = [];
        let airbnbMarkers = []; // Store Airbnb markers for easy removal
        let airbnbRadiusCircle = null; // Store the 300m radius circle

        // Parse CSV text into array of objects
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return []; // Need at least header + 1 row

            // Parse header
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            
            // Find required columns
            const nameIdx = headers.findIndex(h => h === 'name' || h === 'condo_name' || h === 'condo');
            const latIdx = headers.findIndex(h => h === 'lat' || h === 'latitude');
            const lonIdx = headers.findIndex(h => h === 'lon' || h === 'lng' || h === 'longitude');

            if (nameIdx === -1 || latIdx === -1 || lonIdx === -1) {
                throw new Error('CSV must contain: name (or condo_name/condo), lat (or latitude), and lon (or lng/longitude) columns');
            }

            // Find optional columns
            const negeriIdx = headers.findIndex(h => h === 'negeri' || h === 'state');
            const daerahIdx = headers.findIndex(h => h === 'daerah' || h === 'district');
            const mukimIdx = headers.findIndex(h => h === 'mukim');
            const seksyenIdx = headers.findIndex(h => h === 'seksyen' || h === 'section');
            const lotIdx = headers.findIndex(h => h === 'lot');
            const developerIdx = headers.findIndex(h => h === 'developer' || h === 'dev');
            const completionYearIdx = headers.findIndex(h => h === 'completion_year' || h === 'completion' || h === 'year');
            const tenureIdx = headers.findIndex(h => h === 'tenure' || h === 'land_tenure');
            const numFloorsIdx = headers.findIndex(h => h === 'number_of_floors' || h === 'floors' || h === 'num_floors');
            const numUnitsIdx = headers.findIndex(h => h === 'number_of_units' || h === 'units' || h === 'num_units');

            // Parse data rows
            const condos = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Handle quoted values (basic CSV parsing)
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());

                const name = values[nameIdx] || 'Unnamed Condo';
                const lat = parseFloat(values[latIdx]);
                const lon = parseFloat(values[lonIdx]);

                // Validate coordinates
                if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                    console.warn(`Skipping invalid row ${i + 1}: invalid coordinates`);
                    continue;
                }

                // Extract optional fields (trim whitespace and use empty string if not found)
                const negeri = negeriIdx >= 0 ? (values[negeriIdx] || '').trim() : '';
                const daerah = daerahIdx >= 0 ? (values[daerahIdx] || '').trim() : '';
                const mukim = mukimIdx >= 0 ? (values[mukimIdx] || '').trim() : '';
                const seksyen = seksyenIdx >= 0 ? (values[seksyenIdx] || '').trim() : '';
                const lot = lotIdx >= 0 ? (values[lotIdx] || '').trim() : '';
                const developer = developerIdx >= 0 ? (values[developerIdx] || '').trim() : '';
                const completionYear = completionYearIdx >= 0 ? (values[completionYearIdx] || '').trim() : '';
                const tenure = tenureIdx >= 0 ? (values[tenureIdx] || '').trim() : '';
                const numFloors = numFloorsIdx >= 0 ? (values[numFloorsIdx] || '').trim() : '';
                const numUnits = numUnitsIdx >= 0 ? (values[numUnitsIdx] || '').trim() : '';

                condos.push({
                    name: name,
                    lat: lat,
                    lon: lon,
                    negeri: negeri,
                    daerah: daerah,
                    mukim: mukim,
                    seksyen: seksyen,
                    lot: lot,
                    developer: developer,
                    completionYear: completionYear,
                    tenure: tenure,
                    numFloors: numFloors,
                    numUnits: numUnits
                });
            }

            return condos;
        }

        // Load CSV from file input
        function loadCSVFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    csvCondos = parseCSV(e.target.result);
                    console.log(`Loaded ${csvCondos.length} condos from CSV`);
                    alert(`Successfully loaded ${csvCondos.length} condos from CSV!`);
                    
                    // If analysis is already running, refresh the condos
                    const firstLocation = getFirstLocation();
                    if (firstLocation) {
                        fetchAndPlotCondos();
                    }
                } catch (error) {
                    console.error('Error parsing CSV:', error);
                    alert('Error loading CSV: ' + error.message);
                }
            };
            reader.onerror = function() {
                alert('Error reading CSV file');
            };
            reader.readAsText(file);
        }

        // Load CSV from URL (if you host the CSV file)
        async function loadCSVFromURL(url) {
            try {
                const response = await fetch(url);
                const csvText = await response.text();
                csvCondos = parseCSV(csvText);
                console.log(`Loaded ${csvCondos.length} condos from CSV URL`);
                return csvCondos;
            } catch (error) {
                console.error('Error loading CSV from URL:', error);
                return [];
            }
        }
        
        // Generate a unique key from Negeri, Daerah, Mukim, Seksyen, Lot
        function generatePropertyKey(negeri, daerah, mukim, seksyen, lot) {
            // Normalize values (trim, handle empty strings, convert to string)
            const n = String(negeri || '').trim();
            const d = String(daerah || '').trim();
            const m = String(mukim || '').trim();
            const s = String(seksyen || '').trim();
            const l = String(lot || '').trim();
            // Create a unique key by joining all fields with a delimiter
            const key = `${n}|${d}|${m}|${s}|${l}`;
            return key;
        }
        
        // Parse past transaction CSV text into a Map keyed by property identifier
        function parsePastTransactionCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return new Map(); // Need at least header + 1 row
            
            // Parse header
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            
            // Find required columns for matching
            const negeriIdx = headers.findIndex(h => h === 'negeri' || h === 'state');
            const daerahIdx = headers.findIndex(h => h === 'daerah' || h === 'district');
            const mukimIdx = headers.findIndex(h => h === 'mukim');
            const seksyenIdx = headers.findIndex(h => h === 'seksyen' || h === 'section');
            const lotIdx = headers.findIndex(h => h === 'lot');
            
            if (negeriIdx === -1 || daerahIdx === -1 || mukimIdx === -1 || seksyenIdx === -1 || lotIdx === -1) {
                console.warn('Past transaction CSV missing required matching columns (negeri, daerah, mukim, seksyen, lot)');
                return new Map();
            }
            
            // Find all other columns (transaction details)
            const transactionMap = new Map();
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle quoted values (basic CSV parsing)
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                
                // Extract matching fields (ensure they're strings and trimmed)
                const negeri = String(values[negeriIdx] || '').trim();
                const daerah = String(values[daerahIdx] || '').trim();
                const mukim = String(values[mukimIdx] || '').trim();
                const seksyen = String(values[seksyenIdx] || '').trim();
                const lot = String(values[lotIdx] || '').trim();
                
                // Generate key
                const key = generatePropertyKey(negeri, daerah, mukim, seksyen, lot);
                
                // Skip if key is invalid (all empty)
                if (key === '||||') {
                    console.warn(`Skipping transaction row ${i + 1}: all matching fields are empty`);
                    continue;
                }
                
                // Debug: Log first few keys for verification
                if (i <= 3) {
                    console.log(`Transaction key ${i}:`, key, { negeri, daerah, mukim, seksyen, lot });
                }
                
                // Build transaction object with all columns
                const transaction = {};
                headers.forEach((header, idx) => {
                    transaction[header] = (values[idx] || '').trim();
                });
                
                // Store in map - if key already exists, create array of transactions
                if (transactionMap.has(key)) {
                    transactionMap.get(key).push(transaction);
                } else {
                    transactionMap.set(key, [transaction]);
                }
            }
            
            return transactionMap;
        }
        
        // Load past transaction CSV from URL
        async function loadPastTransactionCSVFromURL(url) {
            try {
                const response = await fetch(url);
                const csvText = await response.text();
                pastTransactions = parsePastTransactionCSV(csvText);
                console.log(`Loaded past transactions for ${pastTransactions.size} properties from CSV URL`);
                
                // Log first few keys for debugging
                const sampleKeys = Array.from(pastTransactions.keys()).slice(0, 5);
                console.log('Sample transaction keys:', sampleKeys);
                
                return pastTransactions;
            } catch (error) {
                console.error('Error loading past transaction CSV from URL:', error);
                return new Map();
            }
        }
        
        // Parse all ads CSV text into a Map keyed by property identifier
        // Stores:
        //  - minimum Sale and Rent prices
        //  - arrays of Sale/Rent asking prices per square foot (price / builtup)
        function parseAllAdsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return new Map(); // Need at least header + 1 row
            
            // Parse header
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            
            // Find required columns for matching
            const negeriIdx = headers.findIndex(h => h === 'negeri' || h === 'state');
            const daerahIdx = headers.findIndex(h => h === 'daerah' || h === 'district');
            const mukimIdx = headers.findIndex(h => h === 'mukim');
            const seksyenIdx = headers.findIndex(h => h === 'seksyen' || h === 'section');
            const lotIdx = headers.findIndex(h => h === 'lot');
            
            // Find listing type column (Sale/Rent)
            const typeIdx = headers.findIndex(h => 
                h === 'type' || 
                h === 'listing type' || 
                h === 'scheme type' ||
                h === 'listing_type' ||
                h === 'scheme_type'
            );
            
            // Find price column
            const priceIdx = headers.findIndex(h => 
                h === 'price' || 
                h === 'price (rm)' ||
                h === 'transacted price (rm)' ||
                h === 'price_rm' ||
                h === 'transacted_price'
            );
            
            // Find builtup area column (for psf calculation)
            const builtupIdx = headers.findIndex(h => {
                const norm = h.replace(/\s+/g, ' ').trim();
                return norm === 'builtup (sqft)' || norm === 'builtup(sqft)' || norm === 'builtup';
            });
            
            if (negeriIdx === -1 || daerahIdx === -1 || mukimIdx === -1 || seksyenIdx === -1 || lotIdx === -1) {
                console.warn('All Ads CSV missing required matching columns (negeri, daerah, mukim, seksyen, lot)');
                return new Map();
            }
            
            if (typeIdx === -1) {
                console.warn('All Ads CSV missing listing type column');
            }
            
            if (priceIdx === -1) {
                console.warn('All Ads CSV missing price column');
            }
            
            if (builtupIdx === -1) {
                console.warn('All Ads CSV missing builtup column - price psf will not be available');
            }
            
            const adsMap = new Map();
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle quoted values (basic CSV parsing)
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                
                // Extract matching fields
                const negeri = String(values[negeriIdx] || '').trim();
                const daerah = String(values[daerahIdx] || '').trim();
                const mukim = String(values[mukimIdx] || '').trim();
                const seksyen = String(values[seksyenIdx] || '').trim();
                const lot = String(values[lotIdx] || '').trim();
                
                // Generate key
                const key = generatePropertyKey(negeri, daerah, mukim, seksyen, lot);
                
                // Skip if key is invalid
                if (key === '||||') {
                    continue;
                }
                
                // Extract listing type and price
                const listingType = typeIdx !== -1 ? String(values[typeIdx] || '').trim().toLowerCase() : '';
                const priceStr = priceIdx !== -1 ? String(values[priceIdx] || '').trim() : '';
                
                // Parse price (remove commas, RM, etc.)
                let price = null;
                if (priceStr) {
                    const cleanedPrice = priceStr.replace(/[RM,\s]/g, '');
                    const parsedPrice = parseFloat(cleanedPrice);
                    if (!isNaN(parsedPrice) && parsedPrice > 0) {
                        price = parsedPrice;
                    }
                }
                
                // Initialize entry if not exists
                if (!adsMap.has(key)) {
                    adsMap.set(key, { 
                        minSalePrice: null, 
                        minRentPrice: null,
                        salePsfValues: [],
                        rentPsfValues: [],
                        builtupValues: [], // Collect all builtup values for median calculation
                        salePrices: [] // Collect all sale prices for median calculation
                    });
                }
                
                const entry = adsMap.get(key);
                
                // Extract builtup area (for median calculation)
                if (builtupIdx !== -1) {
                    const builtupStr = String(values[builtupIdx] || '').trim();
                    if (builtupStr) {
                        const builtupClean = builtupStr.replace(/[^0-9.]/g, '');
                        const builtup = parseFloat(builtupClean);
                        if (!isNaN(builtup) && builtup > 0) {
                            entry.builtupValues.push(builtup);
                        }
                    }
                }
                
                // Compute price per square foot if we have builtup
                let pricePsf = null;
                if (price !== null && builtupIdx !== -1) {
                    const builtupStr = String(values[builtupIdx] || '').trim();
                    if (builtupStr) {
                        const builtupClean = builtupStr.replace(/[^0-9.]/g, '');
                        const builtup = parseFloat(builtupClean);
                        if (!isNaN(builtup) && builtup > 0) {
                            pricePsf = price / builtup;
                        }
                    }
                }
                
                // Update minimum prices & collect psf samples based on listing type
                if (listingType === 'sale' && price !== null) {
                    if (entry.minSalePrice === null || price < entry.minSalePrice) {
                        entry.minSalePrice = price;
                    }
                    // Collect all sale prices for median calculation
                    entry.salePrices.push(price);
                    if (pricePsf !== null) {
                        entry.salePsfValues.push(pricePsf);
                    }
                } else if (listingType === 'rent' && price !== null) {
                    if (entry.minRentPrice === null || price < entry.minRentPrice) {
                        entry.minRentPrice = price;
                    }
                    if (pricePsf !== null) {
                        entry.rentPsfValues.push(pricePsf);
                    }
                }
            }
            
            return adsMap;
        }
        
        // Load all ads CSV from URL
        async function loadAllAdsCSVFromURL(url) {
            try {
                const response = await fetch(url);
                const csvText = await response.text();
                allAds = parseAllAdsCSV(csvText);
                console.log(`Loaded ads data for ${allAds.size} properties from CSV URL`);
                
                // Log first few keys for debugging
                const sampleKeys = Array.from(allAds.keys()).slice(0, 5);
                console.log('Sample ads keys:', sampleKeys);
                
                return allAds;
            } catch (error) {
                console.error('Error loading all ads CSV from URL:', error);
                return new Map();
            }
        }
        
        // Parse Airbnb CSV text into array of objects
        function parseAirbnbCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return []; // Need at least header + 1 row
            
            // Parse header
            const headers = lines[0].split(',').map(h => h.trim());
            
            // Find required columns (case-insensitive matching)
            const priceIdx = headers.findIndex(h => 
                h.toLowerCase() === 'price_per_night' || 
                h.toLowerCase() === 'price per night' ||
                h.toLowerCase() === 'pricepernight'
            );
            const latIdx = headers.findIndex(h => 
                h.toLowerCase() === 'latitude' || 
                h.toLowerCase() === 'lat'
            );
            const lonIdx = headers.findIndex(h => 
                h.toLowerCase() === 'longitude' || 
                h.toLowerCase() === 'lon' ||
                h.toLowerCase() === 'lng'
            );
            
            if (priceIdx === -1 || latIdx === -1 || lonIdx === -1) {
                console.warn('Airbnb CSV missing required columns (Price_per_night, Latitude, Longitude)');
                return [];
            }
            
            const listings = [];
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle quoted values (basic CSV parsing)
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                
                // Extract values
                const priceStr = values[priceIdx] || '';
                const latStr = values[latIdx] || '';
                const lonStr = values[lonIdx] || '';
                
                // Parse price (remove commas, RM, etc.)
                const cleanedPrice = priceStr.replace(/[RM,\s]/g, '');
                const price = parseFloat(cleanedPrice);
                
                // Parse coordinates
                const lat = parseFloat(latStr);
                const lon = parseFloat(lonStr);
                
                // Validate data
                if (!isNaN(price) && price > 0 && !isNaN(lat) && !isNaN(lon) && 
                    lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    listings.push({
                        pricePerNight: price,
                        lat: lat,
                        lon: lon
                    });
                }
            }
            
            return listings;
        }
        
        // Load Airbnb CSV from URL
        async function loadAirbnbCSVFromURL(url) {
            try {
                const response = await fetch(url);
                const csvText = await response.text();
                airbnbListings = parseAirbnbCSV(csvText);
                console.log(`Loaded ${airbnbListings.length} Airbnb listings from CSV URL`);
                return airbnbListings;
            } catch (error) {
                console.error('Error loading Airbnb CSV from URL:', error);
                return [];
            }
        }
        
        // Clear all Airbnb markers and radius circle from the map
        function clearAirbnbMarkers() {
            airbnbMarkers.forEach(marker => map.removeLayer(marker));
            airbnbMarkers = [];
            if (airbnbRadiusCircle) {
                map.removeLayer(airbnbRadiusCircle);
                airbnbRadiusCircle = null;
            }
        }
        
        // Plot Airbnb listings within 300m radius of a given location
        function plotAirbnbNearby(centerLat, centerLon) {
            // Clear previous Airbnb markers
            clearAirbnbMarkers();
            
            if (!airbnbListings || airbnbListings.length === 0) {
                console.log('No Airbnb listings loaded');
                return;
            }
            
            // Filter listings within 300m radius
            const nearbyListings = airbnbListings.filter(listing => {
                const distance = calculateDistance(centerLat, centerLon, listing.lat, listing.lon);
                return distance <= 300; // 300 meters
            });
            
            console.log(`Found ${nearbyListings.length} Airbnb listings within 300m`);
            
            // Draw 300m radius circle around the selected condo
            airbnbRadiusCircle = L.circle([centerLat, centerLon], {
                radius: 300, // 300 meters
                color: '#ff385c',
                fillColor: '#ff385c',
                fillOpacity: 0.1,
                weight: 2,
                dashArray: '5, 5'
            }).addTo(map);
            
            // Plot markers with price labels
            nearbyListings.forEach(listing => {
                // Create custom icon with price displayed on the marker
                const priceText = `RM ${listing.pricePerNight.toFixed(0)}`;
                const airbnbIcon = L.divIcon({
                    className: 'airbnb-marker',
                    html: `
                        <div style="position: relative;">
                            <div style="background: #ff385c; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>
                            <div style="position: absolute; top: 28px; left: 50%; transform: translateX(-50%); white-space: nowrap; background: rgba(255, 255, 255, 0.95); padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600; color: #ff385c; box-shadow: 0 1px 3px rgba(0,0,0,0.2); border: 1px solid #ff385c;">
                                ${priceText}
                            </div>
                        </div>
                    `,
                    iconSize: [60, 40],
                    iconAnchor: [12, 12],
                    popupAnchor: [0, -40]
                });
                
                const marker = L.marker([listing.lat, listing.lon], { icon: airbnbIcon })
                    .bindPopup(`<strong>Airbnb Listing</strong><br>Price per night: RM ${listing.pricePerNight.toFixed(2)}`)
                    .addTo(map);
                airbnbMarkers.push(marker);
            });
        }

        // Fetch condos from Overpass and plot them on map + sidebar
        async function fetchAndPlotCondos() {
            const firstLocation = getFirstLocation();
            if (!firstLocation) {
                alert('Please pin at least one location first.');
                return;
            }

            // Clear existing condo markers, routes, and Airbnb markers
            condoMarkers.forEach(m => map.removeLayer(m));
            condoMarkers = [];
            clearAirbnbMarkers();
            condoLayer0to3km.clearLayers();
            condoLayer3to6km.clearLayers();
            condoLayer6to9km.clearLayers();
            condoLayer9to12km.clearLayers();
            clearRoutes();
            currentCondoMarker = null;
            
            // Restore budget max options when starting new analysis
            restoreBudgetMaxOptions();

            // Clear sidebar and show loading state (will be updated in fetchAndPlotCondos)
            const condosList = document.getElementById('condosList');
            if (condosList) {
                condosList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-light);"><div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">Analyzing...</div><div style="font-size: 0.85rem;">Finding condos within 12km radius</div></div>';
            }

            const primaryLocation = getFirstLocation();
            if (!primaryLocation) {
                alert('Please pin at least one location first.');
                return;
            }
            const workLat = primaryLocation.lat;
            const workLng = primaryLocation.lng;

            try {
                // Skip Overpass API call - we're only using CSV data
                // Clear loading state and restore structure for results
                const condosList = document.getElementById('condosList');
                if (condosList) {
                    condosList.innerHTML = `
                        <div class="condo-items" id="allCondos"></div>
                    `;
                }

                // Check if we have CSV condos loaded
                if (!csvCondos || csvCondos.length === 0) {
                    // Show empty state
                    if (condosList) {
                        condosList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-light);"><div style="font-size: 0.9rem;">No condos found. Please load a CSV file with condo data.</div></div>';
                    }
                    return;
                }

                // Initialize single array for all condos
                const allCondos = [];

                // TEMP: Hide Overpass (OpenStreetMap) condos and only use CSV condos
                // If you want to re-enable Overpass condos later, uncomment the block below.
                /*
                data.elements.forEach(el => {
                    const lat = el.lat || (el.center && el.center.lat);
                    const lon = el.lon || (el.center && el.center.lon);
                    if (typeof lat !== 'number' || typeof lon !== 'number') return;

                    const tags = el.tags || {};
                    const name = tags.name || 'Unnamed Condo';

                    // Calculate distance from work location
                    const distanceMeters = calculateDistance(workLat, workLng, lat, lon);
                    const distanceKm = (distanceMeters / 1000).toFixed(2);

                    // Skip if outside 12km
                    if (distanceMeters > 12000) return;

                    const band = getDistanceBand(distanceMeters);
                    if (!band) return;

                    condosByBand[band].push({
                        name,
                        lat,
                        lon,
                        distanceKm,
                        distanceMeters
                    });
                });
                */

                // Get budget range from sidebar
                const sidebarBudgetMin = document.getElementById('sidebarBudgetMin');
                const sidebarBudgetMax = document.getElementById('sidebarBudgetMax');
                const minBudget = sidebarBudgetMin && sidebarBudgetMin.value ? parseInt(sidebarBudgetMin.value) : 0;
                const maxBudget = sidebarBudgetMax && sidebarBudgetMax.value ? parseInt(sidebarBudgetMax.value) : null;
                
                // Get property size range from sidebar
                const sidebarPropertySizeMin = document.getElementById('sidebarPropertySizeMin');
                const sidebarPropertySizeMax = document.getElementById('sidebarPropertySizeMax');
                const advancedPropertySizeMin = document.getElementById('advancedPropertySizeMin');
                const advancedPropertySizeMax = document.getElementById('advancedPropertySizeMax');
                // Use advanced filter values if available, otherwise use standard filter values
                const minPropertySize = (advancedPropertySizeMin && advancedPropertySizeMin.value) 
                    ? parseInt(advancedPropertySizeMin.value) 
                    : (sidebarPropertySizeMin && sidebarPropertySizeMin.value ? parseInt(sidebarPropertySizeMin.value) : null);
                const maxPropertySize = (advancedPropertySizeMax && advancedPropertySizeMax.value) 
                    ? parseInt(advancedPropertySizeMax.value) 
                    : (sidebarPropertySizeMax && sidebarPropertySizeMax.value ? parseInt(sidebarPropertySizeMax.value) : null);

                // Process condos from CSV database only
                csvCondos.forEach(csvCondo => {
                    const lat = csvCondo.lat;
                    const lon = csvCondo.lon;
                    const name = csvCondo.name || 'Unnamed Condo';

                    // Calculate distances to all pinned locations
                    const distancesToLocations = [];
                    let minDistanceMeters = Infinity;
                    
                    questionnaireData.locations.forEach(location => {
                        const distanceMeters = calculateDistance(location.lat, location.lng, lat, lon);
                        const distanceKm = (distanceMeters / 1000).toFixed(2);
                        
                        distancesToLocations.push({
                            locationType: location.locationType || 'Location',
                            distanceMeters: distanceMeters,
                            distanceKm: distanceKm
                        });
                        
                        // Track minimum distance for filtering
                        if (distanceMeters < minDistanceMeters) {
                            minDistanceMeters = distanceMeters;
                        }
                    });

                    // Skip if outside 12km from all locations
                    if (minDistanceMeters > 12000) return;

                    // Filter by budget: check if median asking sales price is within budget range
                    if (maxBudget !== null) {
                        // Generate property key to look up median asking sales price
                        const propertyKey = generatePropertyKey(
                            csvCondo.negeri || '',
                            csvCondo.daerah || '',
                            csvCondo.mukim || '',
                            csvCondo.seksyen || '',
                            csvCondo.lot || ''
                        );
                        
                        // Get median asking sales price from All_Ads
                        let medianSalePrice = null;
                        if (allAds && allAds.has(propertyKey)) {
                            const adsEntry = allAds.get(propertyKey);
                            const salePrices = adsEntry.salePrices || [];
                            if (salePrices.length > 0) {
                                medianSalePrice = calculateMedian(salePrices);
                            }
                        }
                        
                        // Skip this condo if median asking sales price is not within budget
                        // If no median price data available, include it (don't filter out)
                        if (medianSalePrice !== null && medianSalePrice > 0) {
                            // Check if median price is within budget range
                            if (medianSalePrice < minBudget || medianSalePrice > maxBudget) {
                                return; // Skip this condo
                            }
                        }
                    }
                    
                    // Filter by property size: check if built-up area is within property size range
                    if (minPropertySize !== null || maxPropertySize !== null) {
                        // Generate property key to look up built-up area data
                        const propertyKey = generatePropertyKey(
                            csvCondo.negeri || '',
                            csvCondo.daerah || '',
                            csvCondo.mukim || '',
                            csvCondo.seksyen || '',
                            csvCondo.lot || ''
                        );
                        
                        // Get built-up area data from All_Ads
                        let minBuiltup = null;
                        let maxBuiltup = null;
                        if (allAds && allAds.has(propertyKey)) {
                            const adsEntry = allAds.get(propertyKey);
                            const builtupValues = adsEntry.builtupValues || [];
                            if (builtupValues.length > 0) {
                                minBuiltup = Math.min(...builtupValues);
                                maxBuiltup = Math.max(...builtupValues);
                            }
                        }
                        
                        // Skip this condo if built-up area is not within property size range
                        // If no built-up data available, include it (don't filter out)
                        if (minBuiltup !== null && maxBuiltup !== null) {
                            // Check if property size range overlaps with user's filter range
                            // Min filter: property's max built-up must be >= user's min
                            if (minPropertySize !== null && maxBuiltup < minPropertySize) {
                                return; // Skip this condo - property is too small
                            }
                            // Max filter: if max is 1,000, show properties where min built-up <= 1,000
                            // This means: skip properties where minimum built-up exceeds user's maximum
                            if (maxPropertySize !== null && minBuiltup > maxPropertySize) {
                                return; // Skip this condo - property minimum exceeds user's maximum
                            }
                        }
                    }
                    
                    // Filter by ROI: check if ROI meets minimum requirement based on investment type
                    const sidebarInvestmentType = document.getElementById('sidebarInvestmentType');
                    const sidebarMinimumROI = document.getElementById('sidebarMinimumROI');
                    const advancedInvestmentType = document.getElementById('advancedInvestmentType');
                    const advancedMinimumROI = document.getElementById('advancedMinimumROI');
                    // Use advanced filter values if available, otherwise use standard filter values
                    const investmentType = (advancedInvestmentType && advancedInvestmentType.value) 
                        ? advancedInvestmentType.value 
                        : (sidebarInvestmentType && sidebarInvestmentType.value ? sidebarInvestmentType.value : null);
                    const minimumROI = (advancedMinimumROI && advancedMinimumROI.value) 
                        ? parseFloat(advancedMinimumROI.value) 
                        : (sidebarMinimumROI && sidebarMinimumROI.value ? parseFloat(sidebarMinimumROI.value) : null);
                    
                    if (investmentType && minimumROI !== null && !isNaN(minimumROI)) {
                        // Generate property key to look up ROI data
                        const propertyKey = generatePropertyKey(
                            csvCondo.negeri || '',
                            csvCondo.daerah || '',
                            csvCondo.mukim || '',
                            csvCondo.seksyen || '',
                            csvCondo.lot || ''
                        );
                        
                        let roi = null;
                        
                        if (investmentType === 'long-stay') {
                            // Calculate Long-term ROI for long-stay investment
                            if (allAds && allAds.has(propertyKey)) {
                                const adsEntry = allAds.get(propertyKey);
                                roi = calculateLongTermROI(adsEntry);
                            }
                            
                            // Skip this condo if Long-term ROI is below minimum requirement
                            if (roi !== null && !isNaN(roi)) {
                                if (roi < minimumROI) {
                                    return; // Skip this condo - Long-term ROI is below minimum requirement
                                }
                            }
                        } else if (investmentType === 'short-stay') {
                            // Calculate Short-term ROI for short-stay investment
                            if (allAds && allAds.has(propertyKey)) {
                                const adsEntry = allAds.get(propertyKey);
                                roi = calculateShortTermROI(adsEntry, lat, lon);
                            }
                            
                            // For short-stay, treat null/invalid ROI as 0% (insufficient Airbnb data)
                            if (roi === null || isNaN(roi)) {
                                roi = 0; // Treat insufficient data as 0% ROI
                            }
                            
                            // Skip this condo if Short-term ROI is below minimum requirement
                            if (roi < minimumROI) {
                                return; // Skip this condo - Short-term ROI is below minimum requirement
                            }
                        }
                    }

                    // Check if this condo already exists (avoid duplicates)
                    const exists = allCondos.some(c => 
                        Math.abs(c.lat - lat) < 0.0001 && Math.abs(c.lon - lon) < 0.0001
                    );

                    if (!exists) {
                        allCondos.push({
                            name,
                            lat,
                            lon,
                            distancesToLocations: distancesToLocations,
                            minDistanceMeters: minDistanceMeters,
                            negeri: csvCondo.negeri || '',
                            daerah: csvCondo.daerah || '',
                            mukim: csvCondo.mukim || '',
                            seksyen: csvCondo.seksyen || '',
                            lot: csvCondo.lot || '',
                            developer: csvCondo.developer || '',
                            completionYear: csvCondo.completionYear || '',
                            tenure: csvCondo.tenure || '',
                            numFloors: csvCondo.numFloors || '',
                            numUnits: csvCondo.numUnits || ''
                        });
                    }
                });

                // Helper function to get color for distance band
                function getDistanceColor(distanceMeters) {
                    if (distanceMeters <= 3000) return '#22c55e'; // green
                    if (distanceMeters <= 6000) return '#3b82f6'; // blue
                    if (distanceMeters <= 9000) return '#f97316'; // orange
                    if (distanceMeters <= 12000) return '#ef4444'; // red
                    return '#6b7280'; // gray for outside range
                }
                
                // Helper function to get distance band for marker color (use minimum distance)
                function getDistanceBandForColor(distanceMeters) {
                    if (distanceMeters <= 3000) return '0to3';
                    if (distanceMeters <= 6000) return '3to6';
                    if (distanceMeters <= 9000) return '6to9';
                    if (distanceMeters <= 12000) return '9to12';
                    return null;
                }
                
                // Define colors and layers for each band (for map markers)
                const bandConfig = {
                    '0to3': { color: '#22c55e', layer: condoLayer0to3km },
                    '3to6': { color: '#3b82f6', layer: condoLayer3to6km },
                    '6to9': { color: '#f97316', layer: condoLayer6to9km },
                    '9to12': { color: '#ef4444', layer: condoLayer9to12km }
                };

                // Check if we have condos
                if (allCondos.length === 0) {
                    const condosList = document.getElementById('condosList');
                    if (condosList) {
                        condosList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-light);"><div style="font-size: 0.9rem;">No condos found matching your criteria.</div></div>';
                    }
                    return;
                }

                // Sort condos by minimum distance (nearest to furthest)
                allCondos.sort((a, b) => a.minDistanceMeters - b.minDistanceMeters);

                // Get container for all condos
                const allCondosContainer = document.getElementById('allCondos');
                if (!allCondosContainer) return;

                // Helper function to create multi-color marker icon
                function createMultiColorMarkerIcon(colors, size, borderWidth) {
                    if (colors.length === 0) {
                        return `<div style="background: #6b7280; width: ${size}px; height: ${size}px; border-radius: 50%; border: ${borderWidth}px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>`;
                    }
                    
                    if (colors.length === 1) {
                        return `<div style="background: ${colors[0]}; width: ${size}px; height: ${size}px; border-radius: 50%; border: ${borderWidth}px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>`;
                    }
                    
                    // For multiple colors, create SVG pie chart style marker
                    const radius = size / 2 - borderWidth;
                    const center = size / 2;
                    const angleStep = 360 / colors.length;
                    let pathData = '';
                    let currentAngle = -90; // Start from top
                    
                    colors.forEach((color, index) => {
                        const startAngle = currentAngle;
                        const endAngle = currentAngle + angleStep;
                        
                        const startRad = (startAngle * Math.PI) / 180;
                        const endRad = (endAngle * Math.PI) / 180;
                        
                        const x1 = center + radius * Math.cos(startRad);
                        const y1 = center + radius * Math.sin(startRad);
                        const x2 = center + radius * Math.cos(endRad);
                        const y2 = center + radius * Math.sin(endRad);
                        
                        const largeArc = angleStep > 180 ? 1 : 0;
                        
                        pathData += `M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z `;
                        
                        currentAngle = endAngle;
                    });
                    
                    return `
                        <svg width="${size}" height="${size}" style="border-radius: 50%; border: ${borderWidth}px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                            ${colors.map((color, index) => {
                                const startAngle = -90 + (index * angleStep);
                                const endAngle = startAngle + angleStep;
                                const startRad = (startAngle * Math.PI) / 180;
                                const endRad = (endAngle * Math.PI) / 180;
                                const x1 = center + radius * Math.cos(startRad);
                                const y1 = center + radius * Math.sin(startRad);
                                const x2 = center + radius * Math.cos(endRad);
                                const y2 = center + radius * Math.sin(endRad);
                                const largeArc = angleStep > 180 ? 1 : 0;
                                return `<path d="M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z" fill="${color}" />`;
                            }).join('')}
                        </svg>
                    `;
                }

                // Plot condos on map and add to sidebar
                // Load monitored condos once before the loop
                const monitoredCondos = await getMonitoredCondos();
                
                allCondos.forEach(condo => {
                    // Get unique colors for all distance bands
                    const uniqueColors = [];
                    const colorSet = new Set();
                    
                    condo.distancesToLocations.forEach(dist => {
                        const color = getDistanceColor(dist.distanceMeters);
                        if (!colorSet.has(color)) {
                            colorSet.add(color);
                            uniqueColors.push(color);
                        }
                    });
                    
                    // Determine marker layer based on minimum distance
                    const minBand = getDistanceBandForColor(condo.minDistanceMeters);
                    const markerLayer = minBand ? bandConfig[minBand].layer : condoLayer0to3km;

                    // Create normal size map marker icon with multiple colors
                    const normalIcon = L.divIcon({
                        className: 'condo-marker',
                        html: createMultiColorMarkerIcon(uniqueColors, 20, 2),
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    // Create enlarged marker icon for hover with multiple colors
                    const enlargedIcon = L.divIcon({
                        className: 'condo-marker',
                        html: createMultiColorMarkerIcon(uniqueColors, 32, 3),
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    });

                    // Build popup text with distances to all locations
                    let popupText = `<strong>${condo.name}</strong><br>`;
                    condo.distancesToLocations.forEach(dist => {
                        popupText += `${dist.distanceKm} km from ${dist.locationType}<br>`;
                    });

                    const marker = L.marker([condo.lat, condo.lon], { icon: normalIcon })
                        .bindPopup(popupText)
                        .on('click', () => {
                            currentCondoMarker = marker;
                            // Find corresponding sidebar element and expand it
                            const condoElements = document.querySelectorAll('.condo-item');
                            const matchingEl = Array.from(condoElements).find(el => 
                                el.dataset.condoLat == condo.lat && el.dataset.condoLng == condo.lon
                            );
                            if (matchingEl) {
                                matchingEl.click();
                            } else {
                                showRoutesToWork(condo.lat, condo.lon, condo.name, null, condo);
                            }
                        });

                    markerLayer.addLayer(marker);
                    condoMarkers.push(marker);

                    // Build distance labels HTML with colored badges
                    let distanceLabelsHTML = '';
                    condo.distancesToLocations.forEach(dist => {
                        const color = getDistanceColor(dist.distanceMeters);
                        distanceLabelsHTML += `<span style="display: inline-block; background: ${color}; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-right: 0.5rem; margin-top: 0.25rem;">${dist.distanceKm}km away from ${dist.locationType}</span>`;
                    });

                    // Generate unique condo ID
                    const condoId = `${condo.lat}_${condo.lon}_${condo.name.replace(/\s+/g, '_')}`;
                    
                    // Check if condo is being monitored
                    const isMonitored = monitoredCondos.some(m => m.id === condoId);
                    
                    // Add to sidebar
                    const condoEl = document.createElement('div');
                    condoEl.className = 'condo-item';
                    condoEl.innerHTML = `
                        <div class="condo-item-header">
                            <div class="condo-item-header-content">
                                <div class="condo-name">${condo.name}</div>
                                <div class="condo-distance" style="display: flex; flex-wrap: wrap; gap: 0.25rem; margin-top: 0.5rem;">
                                    ${distanceLabelsHTML}
                                </div>
                            </div>
                            <div class="condo-monitor-toggle-wrapper">
                                <div class="condo-monitor-toggle ${isMonitored ? 'monitoring' : ''}" 
                                     onclick="toggleCondoMonitoring(event, '${condoId}', '${condo.name.replace(/'/g, "\\'")}', ${condo.lat}, ${condo.lon})"
                                     title="${isMonitored ? 'Remove from monitoring' : 'Add to monitoring'}">
                                    <span class="condo-monitor-toggle-slider"></span>
                                </div>
                            </div>
                        </div>
                        <div class="condo-item-details"></div>
                    `;
                    
                    // Store condo data on element for route fetching
                    condoEl.dataset.condoLat = condo.lat;
                    condoEl.dataset.condoLng = condo.lon;
                    condoEl.dataset.condoName = condo.name;
                    condoEl.dataset.condoId = condoId;
                    
                    // Add property information (Sale, Rent, Property Size) from All_Ads
                    const propertyKey = generatePropertyKey(
                        condo.negeri || '',
                        condo.daerah || '',
                        condo.mukim || '',
                        condo.seksyen || '',
                        condo.lot || ''
                    );
                    
                    const adsData = allAds ? allAds.get(propertyKey) : null;
                    if (adsData) {
                        let propertyInfoHtml = '<div class="condo-property-info">';
                        
                        // Sale From
                        if (adsData.minSalePrice !== null) {
                            const formattedSalePrice = adsData.minSalePrice.toLocaleString('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2
                            });
                            propertyInfoHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Sale</div>
                                    <div class="condo-property-value">From RM ${formattedSalePrice}</div>
                                </div>
                            `;
                        }
                        
                        // Rent From
                        if (adsData.minRentPrice !== null) {
                            const formattedRentPrice = adsData.minRentPrice.toLocaleString('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2
                            });
                            propertyInfoHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Rent</div>
                                    <div class="condo-property-value">From RM ${formattedRentPrice}</div>
                                </div>
                            `;
                        }
                        
                        // Property Size (Minimum Built-up Area)
                        if (adsData.builtupValues && adsData.builtupValues.length > 0) {
                            const minBuiltup = Math.min(...adsData.builtupValues);
                            const formattedBuiltup = minBuiltup.toLocaleString('en-US', {
                                minimumFractionDigits: 0,
                                maximumFractionDigits: 0
                            });
                            propertyInfoHtml += `
                                <div class="condo-property-item">
                                    <div class="condo-property-label"> Property Size</div>
                                    <div class="condo-property-value">From ${formattedBuiltup} sqft</div>
                                </div>
                            `;
                        }
                        
                        propertyInfoHtml += '</div>';
                        const detailsEl = condoEl.querySelector('.condo-item-details');
                        if (detailsEl) {
                            detailsEl.innerHTML = propertyInfoHtml;
                        }
                    }
                    
                    // Hover handlers to enlarge/shrink marker
                    condoEl.addEventListener('mouseenter', () => {
                        marker.setIcon(enlargedIcon);
                    });
                    
                    condoEl.addEventListener('mouseleave', () => {
                        marker.setIcon(normalIcon);
                    });
                    
                    // Click handler: zoom to show both work location and condo, and show routes
                    condoEl.onclick = () => {
                        currentCondoMarker = marker;
                        
                        // Toggle expanded state
                        const isExpanded = condoEl.classList.contains('expanded');
                        
                        const firstLocation = getFirstLocation();
                        if (firstLocation) {
                            // Create bounds that include both first location and condo
                            const bounds = L.latLngBounds(
                                [[firstLocation.lat, firstLocation.lng]],
                                [[condo.lat, condo.lon]]
                            );
                            // Fit map to show both locations with some padding
                            map.fitBounds(bounds, { padding: [60, 60] });
                            
                            // Show routes if not already expanded, or if collapsed
                            if (!isExpanded) {
                                showRoutesToWork(condo.lat, condo.lon, condo.name, condoEl, condo);
                            } else {
                                // Just collapse
                                condoEl.classList.remove('expanded');
                                clearRoutes();
                            }
                        } else {
                            // Fallback: just center on condo if work location not set
                            map.setView([condo.lat, condo.lon], 16);
                            if (!isExpanded) {
                                condoEl.classList.add('expanded');
                            } else {
                                condoEl.classList.remove('expanded');
                            }
                        }
                        marker.openPopup();
                    };
                    
                    allCondosContainer.appendChild(condoEl);
                });

                // Add all layers to map
                Object.keys(bandConfig).forEach(band => {
                    const config = bandConfig[band];
                    if (config.layer.getLayers().length > 0 && !map.hasLayer(config.layer)) {
                        config.layer.addTo(map);
                    }
                });

                // Show condo panel
                document.getElementById('condosPanel').style.display = 'block';

            } catch (err) {
                console.error('Error fetching condos:', err);
                alert('Failed to load condos. Please try again.');
            }
        }

        function submitQuestionnaire() {
            // Validate step 3
            const budget = document.getElementById('budget').value;
            if (!budget) {
                alert('Please select your budget range');
                return;
            }
            
            questionnaireData.budget = budget;
            
            // Store data
            localStorage.setItem('propertyzap_questionnaire', JSON.stringify(questionnaireData));
            
            // TODO: Send to backend/API
            console.log('Questionnaire data:', questionnaireData);
            
            // Show success message
            alert('Thank you! Your personalized property recommendations are being prepared...');
            
            // TODO: Load property recommendations on map
        }

        // Monitoring and Notification System
        let cachedMonitoredCondos = null; // Cache to avoid repeated API calls
        
        async function getMonitoredCondos() {
            // Return cached value if available
            if (cachedMonitoredCondos !== null) {
                return cachedMonitoredCondos;
            }
            
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) {
                    // Fallback to localStorage if no username
                    const stored = localStorage.getItem('propertyzap_monitored_condos');
                    return stored ? JSON.parse(stored) : [];
                }
                
                // Load from backend
                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`);
                if (res.ok) {
                    const data = await res.json();
                    cachedMonitoredCondos = data.monitoredCondos || [];
                    // Also sync to localStorage for compatibility
                    localStorage.setItem('propertyzap_monitored_condos', JSON.stringify(cachedMonitoredCondos));
                    return cachedMonitoredCondos;
                }
            } catch (e) {
                console.warn('Error loading monitored condos from backend, falling back to localStorage:', e);
            }
            
            // Fallback to localStorage
            try {
                const stored = localStorage.getItem('propertyzap_monitored_condos');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                return [];
            }
        }

        async function saveMonitoredCondos(condos) {
            // Update cache
            cachedMonitoredCondos = condos;
            
            // Save to localStorage for compatibility
            localStorage.setItem('propertyzap_monitored_condos', JSON.stringify(condos));
            
            // Save to backend
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) return;
                
                const payload = {
                    monitoredCondos: condos
                };
                
                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!res.ok) {
                    console.warn('Failed to save monitored condos to backend');
                }
            } catch (e) {
                console.warn('Error saving monitored condos to backend:', e);
            }
        }

        function getNotifications() {
            try {
                const stored = localStorage.getItem('propertyzap_notifications');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                return [];
            }
        }

        function saveNotifications(notifications) {
            localStorage.setItem('propertyzap_notifications', JSON.stringify(notifications));
            updateNotificationBadge();
        }

        function addNotification(type, title, message, condoId, condoName) {
            const notifications = getNotifications();
            const notification = {
                id: 'notif_' + Date.now(),
                type: type, // 'transaction', 'new_listing', etc.
                title: title,
                message: message,
                condoId: condoId,
                condoName: condoName,
                timestamp: new Date().toISOString(),
                read: false
            };
            notifications.unshift(notification);
            // Keep only last 50 notifications
            if (notifications.length > 50) {
                notifications.splice(50);
            }
            saveNotifications(notifications);
            renderNotifications();
        }

        async function toggleCondoMonitoring(event, condoId, condoName, lat, lng) {
            event.stopPropagation();
            
            const monitoredCondos = await getMonitoredCondos();
            // Ensure it's an array
            if (!Array.isArray(monitoredCondos)) {
                console.error('monitoredCondos is not an array:', monitoredCondos);
                return;
            }
            const index = monitoredCondos.findIndex(m => m.id === condoId);
            
            if (index >= 0) {
                // Remove from monitoring
                monitoredCondos.splice(index, 1);
                saveMonitoredCondos(monitoredCondos);
                
                // Update toggle
                const toggle = event.target.closest('.condo-monitor-toggle');
                if (toggle) {
                    toggle.classList.remove('monitoring');
                    toggle.title = 'Add to monitoring';
                }
            } else {
                // Add to monitoring
                monitoredCondos.push({
                    id: condoId,
                    name: condoName,
                    lat: lat,
                    lng: lng,
                    addedAt: new Date().toISOString()
                });
                saveMonitoredCondos(monitoredCondos);
                
                // Update toggle
                const toggle = event.target.closest('.condo-monitor-toggle');
                if (toggle) {
                    toggle.classList.add('monitoring');
                    toggle.title = 'Remove from monitoring';
                }
                
                // Show confirmation
                addNotification('monitoring', 'Added to Monitoring', `${condoName} has been added to your monitoring list.`, condoId, condoName);
            }
        }

        function updateNotificationBadge() {
            const notifications = getNotifications();
            const unreadCount = notifications.filter(n => !n.read).length;
            const badge = document.getElementById('notificationBadge');
            if (badge) {
                if (unreadCount > 0) {
                    badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        function renderNotifications() {
            const notifications = getNotifications();
            const list = document.getElementById('notificationList');
            if (!list) return;

            if (notifications.length === 0) {
                list.innerHTML = '<div class="notification-empty">No notifications</div>';
                return;
            }

            list.innerHTML = notifications.map(notif => {
                const timeAgo = getTimeAgo(notif.timestamp);
                return `
                    <div class="notification-item ${notif.read ? '' : 'unread'}" onclick="markNotificationRead('${notif.id}')">
                        <div class="notification-item-title">${notif.title}</div>
                        <div class="notification-item-message">${notif.message}</div>
                        <div class="notification-item-time">${timeAgo}</div>
                    </div>
                `;
            }).join('');
        }

        function getTimeAgo(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diffMs = now - time;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
            return time.toLocaleDateString();
        }

        function markNotificationRead(notificationId) {
            const notifications = getNotifications();
            const notif = notifications.find(n => n.id === notificationId);
            if (notif) {
                notif.read = true;
                saveNotifications(notifications);
                renderNotifications();
            }
        }

        function clearAllNotifications() {
            if (confirm('Clear all notifications?')) {
                saveNotifications([]);
                renderNotifications();
            }
        }

        function toggleNotificationDropdown() {
            const dropdown = document.getElementById('notificationDropdown');
            if (dropdown) {
                const isVisible = dropdown.style.display !== 'none';
                dropdown.style.display = isVisible ? 'none' : 'block';
                
                if (!isVisible) {
                    // Mark all as read when opening
                    const notifications = getNotifications();
                    notifications.forEach(n => n.read = true);
                    saveNotifications(notifications);
                    renderNotifications();
                }
            }
        }

        // Close notification dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const bell = document.getElementById('notificationBell');
            const dropdown = document.getElementById('notificationDropdown');
            if (bell && dropdown && !bell.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Simulate notifications for monitored condos (for demo purposes)
        async function checkForUpdates() {
            const monitoredCondos = await getMonitoredCondos();
            if (monitoredCondos.length === 0) return;

            // Simulate random notifications (in production, this would check actual data)
            // For demo: randomly generate notifications
            if (Math.random() < 0.1) { // 10% chance per check
                const randomCondo = monitoredCondos[Math.floor(Math.random() * monitoredCondos.length)];
                const types = ['transaction', 'new_listing'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                if (type === 'transaction') {
                    addNotification('transaction', 'New Transaction', 
                        `A new transaction was recorded for ${randomCondo.name}.`, 
                        randomCondo.id, randomCondo.name);
                } else if (type === 'new_listing') {
                    addNotification('new_listing', 'New Listing', 
                        `A new listing was added for ${randomCondo.name}.`, 
                        randomCondo.id, randomCondo.name);
                }
            }
        }

        // Check for updates every 30 seconds (for demo)
        setInterval(checkForUpdates, 30000);

        // Load pinned locations from backend
        async function loadPinnedLocationsFromBackend() {
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) return null;
                
                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`);
                if (res.ok) {
                    const data = await res.json();
                    return data.pinnedLocations || [];
                }
            } catch (e) {
                console.warn('Error loading pinned locations from backend:', e);
            }
            return null;
        }

        // Load filter preferences from backend
        async function loadFilterPreferencesFromBackend() {
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) return null;
                
                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`);
                if (res.ok) {
                    const data = await res.json();
                    return {
                        purpose: data.purpose || 'own-stay',
                        budgetMin: data.budgetMin,
                        budgetMax: data.budgetMax,
                        propertySizeMin: data.propertySizeMin,
                        propertySizeMax: data.propertySizeMax,
                        investmentType: data.investmentType,
                        minimumROI: data.minimumROI
                    };
                }
            } catch (e) {
                console.warn('Error loading filter preferences from backend:', e);
            }
            return null;
        }

        // Save filter preferences to backend
        async function saveFilterPreferencesToBackend() {
            try {
                const username = localStorage.getItem('propertyzap_username');
                if (!username) return;

                const purpose = questionnaireData.purpose || 'own-stay';
                const budgetMinEl = document.getElementById('sidebarBudgetMin');
                const budgetMaxEl = document.getElementById('sidebarBudgetMax');
                const propertySizeMinEl = document.getElementById('sidebarPropertySizeMin');
                const propertySizeMaxEl = document.getElementById('sidebarPropertySizeMax');
                const investmentTypeEl = document.getElementById('sidebarInvestmentType');
                const minimumROIEl = document.getElementById('sidebarMinimumROI');

                const payload = {
                    purpose: purpose,
                    budgetMin: budgetMinEl && budgetMinEl.value ? parseInt(budgetMinEl.value) : null,
                    budgetMax: budgetMaxEl && budgetMaxEl.value ? parseInt(budgetMaxEl.value) : null,
                    propertySizeMin: propertySizeMinEl && propertySizeMinEl.value ? parseInt(propertySizeMinEl.value) : null,
                    propertySizeMax: propertySizeMaxEl && propertySizeMaxEl.value ? parseInt(propertySizeMaxEl.value) : null,
                    investmentType: investmentTypeEl && investmentTypeEl.value ? investmentTypeEl.value : null,
                    minimumROI: minimumROIEl && minimumROIEl.value ? parseFloat(minimumROIEl.value) : null
                };

                const res = await fetch(`${API_BASE}/api/users/${encodeURIComponent(username)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!res.ok) {
                    console.warn('Failed to save filter preferences to backend');
                }
            } catch (e) {
                console.warn('Error saving filter preferences to backend:', e);
            }
        }

        // Check if user is signed in
        window.addEventListener('DOMContentLoaded', async () => {
            const isSignedUp = localStorage.getItem('propertyzap_signed_up');
            if (isSignedUp !== 'true') {
                // Redirect to sign-in if not signed in
                window.location.href = 'sign-in.html';
                return;
            }

            // Initialize notifications
            updateNotificationBadge();
            renderNotifications();
            
            // First, try to load pinned locations and filter preferences from backend
            const backendPinnedLocations = await loadPinnedLocationsFromBackend();
            const backendFilterPrefs = await loadFilterPreferencesFromBackend();
            
            // Check if questionnaire data exists in localStorage
            let questionnaireDataStr = localStorage.getItem('propertyzap_questionnaire');
            let qData = null;
            
            // If we have backend pinned locations but no localStorage data, create questionnaire data from backend
            if (backendPinnedLocations && backendPinnedLocations.length > 0 && !questionnaireDataStr) {
                // Create questionnaire data structure from backend pinned locations
                qData = {
                    purpose: '', // Will be set if available in backend
                    locations: backendPinnedLocations,
                    budget: { min: null, max: null },
                    propertySize: { min: null, max: null, unit: 'sqft' },
                    purposeData: {
                        investmentType: null,
                        minimumROI: null,
                        targetRental: null
                    }
                };
                // Save to localStorage for compatibility
                localStorage.setItem('propertyzap_questionnaire', JSON.stringify(qData));
            } else if (questionnaireDataStr) {
                // Parse existing localStorage data
                try {
                    qData = JSON.parse(questionnaireDataStr);
                    // If backend has pinned locations, merge them (backend takes priority)
                    if (backendPinnedLocations && backendPinnedLocations.length > 0) {
                        qData.locations = backendPinnedLocations;
                        // Update localStorage with merged data
                        localStorage.setItem('propertyzap_questionnaire', JSON.stringify(qData));
                    }
                } catch (e) {
                    console.warn('Error parsing questionnaire data from localStorage:', e);
                    qData = null;
                }
            }
            
            // If we have questionnaire data (from localStorage or backend), load it
            if (qData) {
                try {
                    console.log('Loaded questionnaire JSON data:', qData);
                    
                    // Load questionnaire data into the app
                    questionnaireData.purpose = qData.purpose || 'own-stay'; // Default to own-stay if not set
                    
                    // Load budget data (support multiple formats, allow individual values)
                    // Priority 1: Structured budget object
                    if (qData.budget && typeof qData.budget === 'object') {
                        // New structured format - allow individual min or max
                        if (qData.budget.min !== null && qData.budget.min !== undefined) {
                            questionnaireData.minBudget = String(qData.budget.min);
                        } else {
                            questionnaireData.minBudget = null;
                        }
                        if (qData.budget.max !== null && qData.budget.max !== undefined) {
                            questionnaireData.maxBudget = String(qData.budget.max);
                        } else {
                            questionnaireData.maxBudget = null;
                        }
                        questionnaireData.budget = qData.budget.range || '';
                    } 
                    // Priority 2: Direct budgetMin/budgetMax properties (from form fields)
                    else if (qData.budgetMin || qData.budgetMax) {
                        questionnaireData.minBudget = (qData.budgetMin && qData.budgetMin !== '') ? String(qData.budgetMin) : null;
                        questionnaireData.maxBudget = (qData.budgetMax && qData.budgetMax !== '') ? String(qData.budgetMax) : null;
                        if (qData.budgetMin && qData.budgetMax) {
                            questionnaireData.budget = `${qData.budgetMin}-${qData.budgetMax}`;
                        } else if (qData.budgetMin) {
                            questionnaireData.budget = `${qData.budgetMin}-`;
                        } else if (qData.budgetMax) {
                            questionnaireData.budget = `-${qData.budgetMax}`;
                        }
                    }
                    // Priority 3: Legacy format support
                    else {
                        questionnaireData.budget = qData.budget || qData.investmentBudget || qData.othersBudget || '';
                        questionnaireData.minBudget = qData.minBudget ? String(qData.minBudget) : null;
                        questionnaireData.maxBudget = qData.maxBudget ? String(qData.maxBudget) : null;
                    }
                    
                    console.log('Budget loaded from JSON:', {
                        minBudget: questionnaireData.minBudget,
                        maxBudget: questionnaireData.maxBudget,
                        budget: questionnaireData.budget,
                        rawData: {
                            budgetObject: qData.budget,
                            budgetMin: qData.budgetMin,
                            budgetMax: qData.budgetMax,
                            minBudget: qData.minBudget,
                            maxBudget: qData.maxBudget
                        }
                    });
                    
                    // Load property size data
                    if (qData.propertySize && typeof qData.propertySize === 'object') {
                        if (qData.propertySize.min !== null && qData.propertySize.min !== undefined) {
                            questionnaireData.propertySize.min = String(qData.propertySize.min);
                        } else {
                            questionnaireData.propertySize.min = null;
                        }
                        if (qData.propertySize.max !== null && qData.propertySize.max !== undefined) {
                            questionnaireData.propertySize.max = String(qData.propertySize.max);
                        } else {
                            questionnaireData.propertySize.max = null;
                        }
                        questionnaireData.propertySize.unit = qData.propertySize.unit || 'sqft';
                    } else if (qData.propertySizeMin || qData.propertySizeMax) {
                        // Direct propertySizeMin/propertySizeMax properties (from form fields)
                        questionnaireData.propertySize.min = (qData.propertySizeMin && qData.propertySizeMin !== '') ? String(qData.propertySizeMin) : null;
                        questionnaireData.propertySize.max = (qData.propertySizeMax && qData.propertySizeMax !== '') ? String(qData.propertySizeMax) : null;
                        questionnaireData.propertySize.unit = 'sqft';
                    }
                    
                    console.log('Property size loaded from JSON:', {
                        min: questionnaireData.propertySize.min,
                        max: questionnaireData.propertySize.max,
                        unit: questionnaireData.propertySize.unit
                    });
                    
                    // Store full JSON data for reference
                    questionnaireData.fullData = qData;
                    
                    // Ensure locations array exists
                    if (!questionnaireData.locations) {
                        questionnaireData.locations = [];
                    }
                    
                    // Load locations if available
                    console.log('Loading locations from questionnaire:', {
                        hasLocations: !!qData.locations,
                        isArray: Array.isArray(qData.locations),
                        locationsCount: qData.locations ? qData.locations.length : 0,
                        locations: qData.locations,
                        purpose: qData.purpose
                    });
                    
                    if (qData.locations && Array.isArray(qData.locations) && qData.locations.length > 0) {
                        console.log('Processing locations, count:', qData.locations.length);
                        console.log('Raw locations data:', qData.locations);
                        
                        qData.locations.forEach((loc, index) => {
                            console.log(`Processing location ${index}:`, loc);
                            
                            // Validate location data - check for name, lat, lng
                            // Accept any locationType including "Preferred" for investment
                            if (loc && loc.name && loc.lat !== undefined && loc.lat !== null && loc.lng !== undefined && loc.lng !== null) {
                                // Preserve the original locationType from the questionnaire
                                // For investment, it should be "Preferred", not "Others"
                                const locationType = loc.locationType || (qData.purpose === 'investment' ? 'Preferred' : 'Work');
                                
                                const locationData = {
                                    id: loc.id || `loc_${Date.now()}_${Math.random()}`,
                                    name: String(loc.name).trim(),
                                    lat: parseFloat(loc.lat),
                                    lng: parseFloat(loc.lng),
                                    locationType: locationType, // Use preserved locationType
                                    opacity: loc.opacity || 0.2
                                };
                                
                                console.log(`Location ${index} processed:`, {
                                    original: loc,
                                    processed: locationData,
                                    locationType: locationData.locationType
                                });
                                
                                // Validate parsed coordinates
                                if (isNaN(locationData.lat) || isNaN(locationData.lng)) {
                                    console.warn('Invalid coordinates for location:', loc);
                                    return; // Skip this location
                                }
                                
                                console.log('Adding location to questionnaireData:', locationData);
                                // Add to questionnaire data first
                                questionnaireData.locations.push(locationData);
                                
                                // Plot marker on map (without adding to questionnaireData again)
                                const marker = L.marker([locationData.lat, locationData.lng], { draggable: true }).addTo(map);
                                
                                // Add popup
                                const latText = locationData.lat.toFixed(4);
                                const lngText = locationData.lng.toFixed(4);
                                marker.bindPopup(`<strong>${locationData.locationType} Location:</strong><br>${locationData.name}<br><small>Lat: ${latText}, Lng: ${lngText}</small>`);
                                
                                // Store marker reference
                                locationMarkers.set(locationData.id, marker);
                                
                                // Update on drag
                                marker.on('dragend', function(e) {
                                    const position = marker.getLatLng();
                                    const updatedLocation = questionnaireData.locations.find(loc => loc.id === locationData.id);
                                    if (updatedLocation) {
                                        updatedLocation.lat = position.lat;
                                        updatedLocation.lng = position.lng;
                                        
                                        // Reverse geocode to update location name
                                        reverseGeocode(position.lat, position.lng).then((newLocationName) => {
                                            updatedLocation.name = newLocationName;
                                            const latText = position.lat.toFixed(4);
                                            const lngText = position.lng.toFixed(4);
                                            const html = `<strong>${updatedLocation.locationType} Location</strong><br>${newLocationName}<br><small>Lat: ${latText}, Lng: ${lngText}</small>`;
                                            marker.bindPopup(html);
                                            renderPinnedLocations();
                                        });
                                    }
                                });
                            }
                        });
                        
                        console.log('Locations loaded into questionnaireData:', {
                            count: questionnaireData.locations.length,
                            locations: questionnaireData.locations
                        });
                        
                        // Render locations in sidebar
                        renderPinnedLocations();
                        
                        // Add work-location-set class to enable interactions
                        if (questionnaireData.locations.length > 0) {
                            document.body.classList.add('work-location-set');
                            
                            // Center map on locations after a short delay to ensure map is initialized
                            setTimeout(() => {
                                if (questionnaireData.locations.length === 1) {
                                    const loc = questionnaireData.locations[0];
                                    map.setView([loc.lat, loc.lng], 13);
                                } else if (questionnaireData.locations.length > 1) {
                                    // Fit bounds to show all locations
                                    const bounds = L.latLngBounds(questionnaireData.locations.map(loc => [loc.lat, loc.lng]));
                                    map.fitBounds(bounds, { padding: [50, 50] });
                                }
                            }, 100);
                        }
                    }
                    
                    // Hide step 1 overlay if purpose is already selected OR if user has pinned locations
                    if (questionnaireData.purpose || (questionnaireData.locations && questionnaireData.locations.length > 0)) {
                        document.getElementById('step1Overlay').classList.add('hidden');
                        currentStep = 2;
                        // Show map search control
                        const mapSearchControl = document.getElementById('mapSearchControl');
                        if (mapSearchControl) {
                            mapSearchControl.classList.remove('hidden');
                        }
                        
                        // Load filter preferences from backend if available
                        if (backendFilterPrefs) {
                            questionnaireData.purpose = backendFilterPrefs.purpose || questionnaireData.purpose || 'own-stay';
                            
                            // Populate filter fields from backend (with delay to ensure DOM is ready)
                            setTimeout(() => {
                                if (backendFilterPrefs.budgetMin) {
                                    const budgetMinEl = document.getElementById('sidebarBudgetMin');
                                    if (budgetMinEl) budgetMinEl.value = backendFilterPrefs.budgetMin;
                                }
                                if (backendFilterPrefs.budgetMax) {
                                    const budgetMaxEl = document.getElementById('sidebarBudgetMax');
                                    if (budgetMaxEl) budgetMaxEl.value = backendFilterPrefs.budgetMax;
                                }
                                if (backendFilterPrefs.propertySizeMin) {
                                    const propertySizeMinEl = document.getElementById('sidebarPropertySizeMin');
                                    if (propertySizeMinEl) propertySizeMinEl.value = backendFilterPrefs.propertySizeMin;
                                }
                                if (backendFilterPrefs.propertySizeMax) {
                                    const propertySizeMaxEl = document.getElementById('sidebarPropertySizeMax');
                                    if (propertySizeMaxEl) propertySizeMaxEl.value = backendFilterPrefs.propertySizeMax;
                                }
                                if (backendFilterPrefs.investmentType) {
                                    const investmentTypeEl = document.getElementById('sidebarInvestmentType');
                                    if (investmentTypeEl) investmentTypeEl.value = backendFilterPrefs.investmentType;
                                    const advancedInvestmentTypeEl = document.getElementById('advancedInvestmentType');
                                    if (advancedInvestmentTypeEl) advancedInvestmentTypeEl.value = backendFilterPrefs.investmentType;
                                }
                                if (backendFilterPrefs.minimumROI !== null && backendFilterPrefs.minimumROI !== undefined) {
                                    const minimumROIEl = document.getElementById('sidebarMinimumROI');
                                    if (minimumROIEl) minimumROIEl.value = backendFilterPrefs.minimumROI;
                                    const advancedMinimumROIEl = document.getElementById('advancedMinimumROI');
                                    if (advancedMinimumROIEl) advancedMinimumROIEl.value = backendFilterPrefs.minimumROI;
                                }
                            }, 200);
                        }
                        
                        // Show/hide filters based on buyer type
                        // If purpose exists, use it; otherwise try to infer from locations or default to own-stay
                        const purpose = questionnaireData.purpose || (qData && qData.purpose) || (backendFilterPrefs && backendFilterPrefs.purpose) || 'own-stay';
                        if (purpose) {
                            questionnaireData.purpose = purpose;
                            updateFiltersByBuyerType(purpose, qData);
                        }
                        
                        // Add event listeners to save filter preferences when changed
                        setTimeout(() => {
                            const filterElements = [
                                'sidebarBudgetMin', 'sidebarBudgetMax', 
                                'sidebarPropertySizeMin', 'sidebarPropertySizeMax',
                                'sidebarInvestmentType', 'sidebarMinimumROI',
                                'advancedInvestmentType', 'advancedMinimumROI',
                                'advancedPropertySizeMin', 'advancedPropertySizeMax'
                            ];
                            
                            filterElements.forEach(id => {
                                const el = document.getElementById(id);
                                if (el) {
                                    el.addEventListener('change', () => {
                                        // Sync advanced filters with standard filters
                                        if (id === 'sidebarInvestmentType') {
                                            const advancedEl = document.getElementById('advancedInvestmentType');
                                            if (advancedEl) advancedEl.value = el.value;
                                        } else if (id === 'sidebarMinimumROI') {
                                            const advancedEl = document.getElementById('advancedMinimumROI');
                                            if (advancedEl) advancedEl.value = el.value;
                                        } else if (id === 'advancedInvestmentType') {
                                            const standardEl = document.getElementById('sidebarInvestmentType');
                                            if (standardEl) standardEl.value = el.value;
                                        } else if (id === 'advancedMinimumROI') {
                                            const standardEl = document.getElementById('sidebarMinimumROI');
                                            if (standardEl) standardEl.value = el.value;
                                        }
                                        saveFilterPreferencesToBackend();
                                    });
                                }
                            });
                        }, 300);
                    }
                    
                    // Set budget in sidebar if provided (with delay to ensure DOM is ready)
                    const setBudget = () => {
                        // Get budget values directly from stored JSON data
                        const storedData = questionnaireData.fullData;
                        let budgetMin = null;
                        let budgetMax = null;
                        
                        console.log('setBudget - Full JSON data:', storedData);
                        console.log('setBudget - questionnaireData:', {
                            minBudget: questionnaireData.minBudget,
                            maxBudget: questionnaireData.maxBudget,
                            budget: questionnaireData.budget
                        });
                        
                        // First, try to get from structured budget object in JSON
                        if (storedData && storedData.budget && typeof storedData.budget === 'object') {
                            if (storedData.budget.min !== null && storedData.budget.min !== undefined && storedData.budget.min !== '') {
                                budgetMin = String(storedData.budget.min);
                            }
                            if (storedData.budget.max !== null && storedData.budget.max !== undefined && storedData.budget.max !== '') {
                                budgetMax = String(storedData.budget.max);
                            }
                            console.log('Extracted from structured budget object:', { budgetMin, budgetMax });
                        }
                        
                        // Second, try direct budgetMin/budgetMax properties (from form fields)
                        if ((!budgetMin || !budgetMax) && storedData) {
                            if (!budgetMin && storedData.budgetMin && storedData.budgetMin !== '') {
                                budgetMin = String(storedData.budgetMin);
                            }
                            if (!budgetMax && storedData.budgetMax && storedData.budgetMax !== '') {
                                budgetMax = String(storedData.budgetMax);
                            }
                            console.log('Extracted from direct budgetMin/budgetMax properties:', { budgetMin, budgetMax });
                        }
                        
                        // Fallback to questionnaireData properties (already set from JSON)
                        if (!budgetMin || !budgetMax) {
                            if (!budgetMin && questionnaireData.minBudget && questionnaireData.minBudget !== 'null' && questionnaireData.minBudget !== '') {
                                budgetMin = String(questionnaireData.minBudget);
                            }
                            if (!budgetMax && questionnaireData.maxBudget && questionnaireData.maxBudget !== 'null' && questionnaireData.maxBudget !== '') {
                                budgetMax = String(questionnaireData.maxBudget);
                            }
                            console.log('Extracted from questionnaireData properties:', { budgetMin, budgetMax });
                        }
                        
                        // If still not set, try to parse from budget string
                        if (!budgetMin || !budgetMax) {
                            if (questionnaireData.budget && typeof questionnaireData.budget === 'string') {
                                const budgetParts = questionnaireData.budget.split('-');
                                if (budgetParts.length === 2) {
                                    budgetMin = budgetParts[0].trim();
                                    budgetMax = budgetParts[1].trim();
                                }
                                console.log('Extracted from budget string:', { budgetMin, budgetMax });
                            }
                        }
                        
                        console.log('Final budget values to set:', { budgetMin, budgetMax });
                        
                        const sidebarBudgetMin = document.getElementById('sidebarBudgetMin');
                        const sidebarBudgetMax = document.getElementById('sidebarBudgetMax');
                        let budgetSet = false;
                        
                        // Set budget min if available (allow setting individually)
                        if (budgetMin && budgetMin !== 'null' && budgetMin !== '' && sidebarBudgetMin) {
                            // Check if the option exists in the dropdown
                            const minOptionExists = Array.from(sidebarBudgetMin.options).some(opt => opt.value === budgetMin);
                            if (minOptionExists) {
                                sidebarBudgetMin.value = budgetMin;
                                questionnaireData.minBudget = budgetMin;
                                // Trigger change event to update state
                                sidebarBudgetMin.dispatchEvent(new Event('change', { bubbles: true }));
                                console.log('Budget Min set successfully:', budgetMin);
                                budgetSet = true;
                            } else {
                                console.warn('Budget Min value not found in dropdown:', budgetMin, 'Available options:', Array.from(sidebarBudgetMin.options).map(opt => opt.value));
                            }
                        }
                        
                        // Set budget max if available (allow setting individually)
                        if (budgetMax && budgetMax !== 'null' && budgetMax !== '' && sidebarBudgetMax) {
                            // Check if the option exists in the dropdown
                            const maxOptionExists = Array.from(sidebarBudgetMax.options).some(opt => opt.value === budgetMax);
                            if (maxOptionExists) {
                                sidebarBudgetMax.value = budgetMax;
                                questionnaireData.maxBudget = budgetMax;
                                // Trigger change event to update state
                                sidebarBudgetMax.dispatchEvent(new Event('change', { bubbles: true }));
                                console.log('Budget Max set successfully:', budgetMax);
                                budgetSet = true;
                            } else {
                                console.warn('Budget Max value not found in dropdown:', budgetMax, 'Available options:', Array.from(sidebarBudgetMax.options).map(opt => opt.value));
                            }
                        }
                        
                        // Add budget-set class if at least one budget value is set
                        if (budgetSet && sidebarBudgetMin && sidebarBudgetMax) {
                            if (sidebarBudgetMin.value || sidebarBudgetMax.value) {
                                document.body.classList.add('budget-set');
                                console.log('Budget successfully loaded from questionnaire JSON:', { 
                                    min: sidebarBudgetMin.value || '(not set)', 
                                    max: sidebarBudgetMax.value || '(not set)' 
                                });
                            }
                        } else if (!budgetMin && !budgetMax) {
                            console.warn('Budget values not found in questionnaire JSON. Values were:', { budgetMin, budgetMax });
                            console.warn('This is normal if budget was not set in the questionnaire (optional field)');
                        }
                        
                        // Set property size dropdowns from questionnaire data
                        const sidebarPropertySizeMin = document.getElementById('sidebarPropertySizeMin');
                        const sidebarPropertySizeMax = document.getElementById('sidebarPropertySizeMax');
                        
                        if (questionnaireData.propertySize.min && questionnaireData.propertySize.min !== 'null' && questionnaireData.propertySize.min !== '' && sidebarPropertySizeMin) {
                            const minOptionExists = Array.from(sidebarPropertySizeMin.options).some(opt => opt.value === questionnaireData.propertySize.min);
                            if (minOptionExists) {
                                sidebarPropertySizeMin.value = questionnaireData.propertySize.min;
                                console.log('Property Size Min set successfully:', questionnaireData.propertySize.min);
                            } else {
                                console.warn('Property Size Min value not found in dropdown:', questionnaireData.propertySize.min);
                            }
                        }
                        
                        if (questionnaireData.propertySize.max && questionnaireData.propertySize.max !== 'null' && questionnaireData.propertySize.max !== '' && sidebarPropertySizeMax) {
                            const maxOptionExists = Array.from(sidebarPropertySizeMax.options).some(opt => opt.value === questionnaireData.propertySize.max);
                            if (maxOptionExists) {
                                sidebarPropertySizeMax.value = questionnaireData.propertySize.max;
                                console.log('Property Size Max set successfully:', questionnaireData.propertySize.max);
                            } else {
                                console.warn('Property Size Max value not found in dropdown:', questionnaireData.propertySize.max);
                            }
                        }
                    };
                    
                    // Set budget after DOM is ready
                    setTimeout(setBudget, 200);
                    
                    // Automatically start analysis if locations are loaded (wait for CSV files to load first)
                    console.log('Checking locations for auto-analysis:', {
                        locations: questionnaireData.locations,
                        locationsLength: questionnaireData.locations ? questionnaireData.locations.length : 0,
                        purpose: questionnaireData.purpose
                    });
                    
                    if (questionnaireData.locations && questionnaireData.locations.length > 0) {
                        console.log('Locations found, will start analysis after CSV files load');
                        // Wait for CSV files to load before starting analysis
                        Promise.all([
                            loadCSVFromURL('condos-sample.csv'),
                            loadPastTransactionCSVFromURL('PropertyZap_PastTransaction.csv'),
                            loadAllAdsCSVFromURL('PropertyZap_All_Ads.csv'),
                            loadAirbnbCSVFromURL('PropertyZap_Airbnb.csv')
                        ]).then(() => {
                            console.log('All CSV files loaded, starting analysis...');
                            // Wait a bit more for map to be fully initialized
                            setTimeout(() => {
                                startSidebarAnalysis();
                            }, 300);
                        }).catch((error) => {
                            console.error('Error loading CSV files:', error);
                            // Still try to start analysis even if some CSV files fail
                            setTimeout(() => {
                                startSidebarAnalysis();
                            }, 1000);
                        });
                    } else {
                        console.log('No locations found, skipping auto-analysis');
                        // If no questionnaire data, load CSV files normally
                        // Auto-load condos from CSV file (if available in the same folder as this HTML)
                        loadCSVFromURL('condos-sample.csv');
                        
                        // Auto-load past transactions from CSV file
                        loadPastTransactionCSVFromURL('PropertyZap_PastTransaction.csv');
                        
                        // Auto-load all ads from CSV file
                        loadAllAdsCSVFromURL('PropertyZap_All_Ads.csv');
                        
                        // Auto-load Airbnb listings from CSV file
                        loadAirbnbCSVFromURL('PropertyZap_Airbnb.csv');
                    }
                } catch (e) {
                    console.error('Error parsing questionnaire data:', e);
                    // If error loading questionnaire, still load CSV files
                    loadCSVFromURL('condos-sample.csv');
                    loadPastTransactionCSVFromURL('PropertyZap_PastTransaction.csv');
                    loadAllAdsCSVFromURL('PropertyZap_All_Ads.csv');
                    loadAirbnbCSVFromURL('PropertyZap_Airbnb.csv');
                }
            } else {
                // No questionnaire data, load CSV files normally
                // Auto-load condos from CSV file (if available in the same folder as this HTML)
                loadCSVFromURL('condos-sample.csv');
                
                // Auto-load past transactions from CSV file
                loadPastTransactionCSVFromURL('PropertyZap_PastTransaction.csv');
                
                // Auto-load all ads from CSV file
                loadAllAdsCSVFromURL('PropertyZap_All_Ads.csv');
                
                // Auto-load Airbnb listings from CSV file
                loadAirbnbCSVFromURL('PropertyZap_Airbnb.csv');
            }
            
            // Show tutorial overlay for Step 1 if tutorial mode is ON and Step 1 is visible
            // Skip tutorial if user already has pinned locations
            const hasPinnedLocations = questionnaireData.locations && questionnaireData.locations.length > 0;
            if (tutorialMode && currentStep === 1 && !hasPinnedLocations) {
                const step1Overlay = document.getElementById('step1Overlay');
                if (step1Overlay && !step1Overlay.classList.contains('hidden')) {
                    setTimeout(() => {
                        showTutorialOverlayStep1();
                    }, 300); // Delay to ensure page is fully loaded
                }
            }
        });
    </script>
</body>
</html>

